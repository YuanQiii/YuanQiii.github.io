<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6特性</title>
    <url>/2022/10/09/ES6%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>方便记忆和预览全部<code>ES6</code>特性</p>
<span id="more"></span>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><p><a href="#es6%E7%89%B9%E6%80%A7">ES6特性</a></p>
<ul>
<li><p><a href="#%E5%A3%B0%E6%98%8E">声明</a></p>
</li>
<li><p><a href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">解构赋值</a></p>
</li>
<li><p><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95">字符串扩展</a></p>
</li>
<li><p><a href="#%E6%95%B0%E5%80%BC%E6%89%A9%E5%B1%95">数值扩展</a></p>
</li>
<li><p><a href="#%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95">对象扩展</a></p>
</li>
<li><p><a href="#%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95">数组扩展</a></p>
</li>
<li><p><a href="#%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95">函数扩展</a></p>
</li>
<li><p><a href="#%E6%AD%A3%E5%88%99%E6%89%A9%E5%B1%95">正则扩展</a></p>
</li>
<li><p><a href="#symbol">Symbol</a></p>
</li>
<li><p><a href="#set">Set</a></p>
</li>
<li><p><a href="#weakset">WeakSet</a></p>
</li>
<li><p><a href="#map">Map</a></p>
</li>
<li><p><a href="#weakmap">WeakMap</a></p>
</li>
<li><p><a href="#proxy">Proxy</a></p>
</li>
<li><p><a href="#reflect">Reflect</a></p>
</li>
<li><p><a href="#class">Class</a></p>
</li>
<li><p><a href="#module">Module</a></p>
</li>
<li><p><a href="#iterator">Iterator</a></p>
</li>
<li><p><a href="#promise">Promise</a></p>
</li>
<li><p><a href="#generator">Generator</a></p>
</li>
<li><p><a href="#async">Async</a></p>
</li>
<li><p><a href="#%E5%8F%82%E8%80%83">参考</a></p>
</li>
</ul>
</li>
</ul>
<h1 id="ES6特性"><a href="#ES6特性" class="headerlink" title="ES6特性"></a>ES6特性</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ol>
<li><p><code>const</code>命令：声明常量</p>
</li>
<li><p><code>let</code>命令：声明变量</p>
</li>
<li><p>注意</p>
<ol>
<li><p>块级作用域</p>
</li>
<li><p>不允许重复声明</p>
</li>
<li><p>不存在变量提升</p>
</li>
<li><p>暂时性死区</p>
</li>
</ol>
</li>
<li><p>共享内存和原子操作：由全局对象<code>SharedArrayBuffer</code>和<code>Atomics</code>实现，将数据存储在一块共享内存空间中，这些数据可在JS主线程和web-worker线程之间共享</p>
</li>
<li><p><code>globalThis</code>：作为顶层对象，指向全局环境下的<code>this</code></p>
<ul>
<li><p><code>Browser</code>：顶层对象是<code>window</code></p>
</li>
<li><p><code>Node</code>：顶层对象是<code>global</code></p>
</li>
<li><p><code>WebWorker</code>：顶层对象是<code>self</code></p>
</li>
<li><p>以上三者：通用顶层对象是<code>globalThis</code></p>
</li>
</ul>
</li>
</ol>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ol>
<li><p>字符串解构：<code>const [a, b, c, d, e] = &quot;hello&quot;</code></p>
</li>
<li><p>数值解构：<code>const &#123; toString: s &#125; = 123</code></p>
</li>
<li><p>布尔解构：<code>const &#123; toString: b &#125; = true</code></p>
</li>
<li><p>对象解构</p>
<ol>
<li><p>形式：<code>const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125;</code></p>
</li>
<li><p>默认：<code>const &#123; x, y = 2 &#125; = &#123; x: 1 &#125;</code></p>
</li>
<li><p>改名：<code>const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125;</code></p>
</li>
<li><p>嵌套：<code>const &#123;x: [&#123;y&#125;]&#125; = &#123;x: [&#123;y: 1&#125;]&#125;</code></p>
</li>
</ol>
</li>
<li><p>数组解构</p>
<ol>
<li><p>规则：数据结构具有<code>Iterator</code>接口可采用数组形式的解构赋值</p>
</li>
<li><p>形式：<code>const [x, y] = [1, 2]</code></p>
</li>
<li><p>默认：<code>const [x, y = 2] = [1]</code></p>
</li>
</ol>
</li>
<li><p>函数参数解构</p>
<ol>
<li><p>数组解构：<code>function Func([x = 0, y = 1]) &#123;&#125;</code></p>
</li>
<li><p>对象解构：<code>function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125;</code></p>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>交换变量值：<code>[x, y] = [y, x]</code></p>
</li>
<li><p>返回函数多个值：<code>const [x, y, z] = Func()</code></p>
</li>
<li><p>定义函数参数：<code>Func([1, 2])</code></p>
</li>
<li><p>提取JSON数据：<code>const &#123; name, version &#125; = packageJson</code></p>
</li>
<li><p>定义函数参数默认值：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></p>
</li>
<li><p>遍历Map结构：<code>for (let [k, v] of Map) &#123;&#125;</code></p>
</li>
<li><p>输入模块指定属性和方法：<code>const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;)</code></p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</p>
</li>
<li><p>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</p>
</li>
<li><p>解构默认值生效条件：属性值严格等于<code>undefined</code></p>
</li>
<li><p>解构遵循匹配模式</p>
</li>
<li><p>解构不成功时变量的值等于<code>undefined</code></p>
</li>
<li><p><code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</p>
</li>
</ol>
</li>
</ol>
<h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h2><ol>
<li><p><code>Unicode</code>表示法：<code>&#39;\uxxxx&#39;</code></p>
</li>
<li><p>字符串遍历：可通过<code>for-of</code>遍历字符串</p>
</li>
<li><p>字符串模板：可单行可多行可插入变量的增强版字符串以及可以换行<code>&#39;$&#123;xxx&#125;&#39;</code></p>
</li>
<li><p>标签模板：函数参数的特殊调用<code>alert`hello`</code> → <code>alert([&#39;hello&#39;])</code>，第一个参数始终都是分割好的字符串数组。其余的参数是模板表达式的值</p>
</li>
<li><p>放松对标签模板里字符串转义的限制：遇到不合法的字符串转义返回<code>undefined</code>，并且从<code>raw</code>上可获取原字符串</p>
</li>
<li><p>直接输入<code>U+2028</code><strong>和</strong><code>U+2029</code>：字符串可直接输入行分隔符和段分隔符</p>
</li>
<li><p><code>JSON.stringify()</code>改造：可返回不符合<code>UTF-8</code>标准的字符串</p>
</li>
<li><p><code>trimStart()</code>：消除字符串头部空格，返回新字符串</p>
</li>
<li><p><code>trimEnd()</code>：消除字符串尾部空格，返回新字符串</p>
</li>
<li><p><code>String.raw()</code>：返回把字符串所有变量替换且对斜杠进行转义的结果</p>
</li>
<li><p><code>String.fromCodePoint()</code>：返回码点对应字符</p>
</li>
<li><p><code>codePointAt()</code>：返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</p>
</li>
<li><p><code>normalize()</code>：把字符的不同表示方法统一为同样形式，返回新字符串(Unicode正规化)</p>
</li>
<li><p><code>repeat()</code>：把字符串重复n次，返回新字符串</p>
</li>
<li><p><code>matchAll()</code>：返回正则表达式在字符串的所有匹配</p>
</li>
<li><p><code>includes()</code>：是否存在指定字符串</p>
</li>
<li><p><code>startsWith()</code>：是否存在字符串头部指定字符串</p>
</li>
<li><p><code>endsWith()</code>：是否存在字符串尾部指定字符串</p>
</li>
<li><p><code>padStart()</code>：把指定字符串填充到字符串头部，参数是新字符串的总长度，如果这个长度比原来的字符串长度短，那么不会填充，返回新字符串</p>
</li>
<li><p><code>padEnd()</code>：把指定字符串填充到字符串尾部，参数是新字符串的总长度，如果这个长度比原来的字符串长度短，那么不会填充，返回新字符串</p>
</li>
<li><p>注意</p>
<ol>
<li>以上扩展方法均可作用于由4个字节储存的<code>Unicode</code>字符上</li>
</ol>
</li>
</ol>
<h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h2><ol>
<li><p>二进制表示法：<code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</p>
</li>
<li><p>八进制表示法：<code>0o或0O开头</code>表示八进制(<code>0oXX</code>或<code>0OXX</code>)</p>
</li>
<li><p><code>Number.EPSILON</code>：数值最小精度</p>
</li>
<li><p><code>Number.MIN_SAFE_INTEGER</code>：最小安全数值(<code>-2^53</code>)</p>
</li>
<li><p><code>Number.MAX_SAFE_INTEGER</code>：最大安全数值(<code>2^53</code>)</p>
</li>
<li><p><code>Number.parseInt()</code>：返回转换值的整数部分</p>
</li>
<li><p><code>Number.parseFloat()</code>：返回转换值的浮点数部分</p>
</li>
<li><p><code>Number.isFinite()</code>：是否为有限数值</p>
</li>
<li><p><code>Number.isNaN()</code>：是否为NaN</p>
</li>
<li><p><code>Number.isInteger()</code>：是否为整数</p>
</li>
<li><p><code>Number.isSafeInteger()</code>：是否在数值安全范围内</p>
</li>
<li><p><code>Math.trunc()</code>：返回数值整数部分</p>
</li>
<li><p><code>Math.sign()</code>：返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</p>
</li>
<li><p><code>Math.cbrt()</code>：返回数值立方根</p>
</li>
<li><p><code>Math.clz32()</code>：返回数值的32位无符号整数形式</p>
</li>
<li><p><code>Math.imul()</code>：返回两个数值相乘</p>
</li>
<li><p><code>Math.fround()</code>：返回数值的32位单精度浮点数形式</p>
</li>
<li><p><code>Math.hypot()</code>：返回所有数值平方和的平方根</p>
</li>
<li><p><code>Math.expm1()</code>：返回<code>e^n - 1</code></p>
</li>
<li><p><code>Math.log1p()</code>：返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</p>
</li>
<li><p><code>Math.log10()</code>：返回以10为底的n的对数</p>
</li>
<li><p><code>Math.log2()</code>：返回以2为底的n的对数</p>
</li>
<li><p><code>Math.sinh()</code>：返回n的双曲正弦</p>
</li>
<li><p><code>Math.cosh()</code>：返回n的双曲余弦</p>
</li>
<li><p><code>Math.tanh()</code>：返回n的双曲正切</p>
</li>
<li><p><code>Math.asinh()</code>：返回n的反双曲正弦</p>
</li>
<li><p><code>Math.acosh()</code>：返回n的反双曲余弦</p>
</li>
<li><p><code>Math.atanh()</code>：返回n的反双曲正切</p>
</li>
<li><p><code>Math.pow()</code>：返回数值求幂</p>
</li>
<li><p><code>BigInt</code>：任何位数的整数(新增的数据类型，使用<code>n</code>结尾)</p>
<ol>
<li><p><code>BigInt()</code>：转换普通数值为<code>BigInt</code>类型</p>
</li>
<li><p><code>BigInt.asUintN()</code>：转换<code>BigInt</code>为<code>0</code>到<code>2n-1</code>之间对应的值</p>
</li>
<li><p><code>BigInt.asIntN()</code>：转换<code>BigInt</code>为<code>-2n-1</code> 到<code>2n-1-1</code></p>
</li>
<li><p><code>BigInt.parseInt()</code>：近似于<code>Number.parseInt()</code>，将一个字符串转换成指定进制的<code>BigInt</code>类型</p>
</li>
<li><p>注意</p>
<ol>
<li><p><code>BigInt</code>同样可使用各种进制表示，都要加上后缀</p>
</li>
<li><p><code>BigInt</code>与普通整数是两种值，它们之间并不相等</p>
</li>
<li><p><code>typeof</code>运算符对于<code>BigInt</code>类型的数据返回<code>bigint</code></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><ol>
<li><p>简洁表示法：直接写入变量和函数作为对象的属性和方法(<code>&#123; prop, method() &#123;&#125; &#125;</code>)</p>
</li>
<li><p>属性名表达式：字面量定义对象时使用<code>[]</code>定义键(<code>[prop]</code>，不能与上同时使用)</p>
</li>
<li><p>属性的可枚举性和遍历：描述对象的<code>enumerable</code></p>
</li>
<li><p><code>super</code>关键字：指向当前对象的原型对象(只能用在对象的简写方法中<code>method() &#123;&#125;</code>)</p>
</li>
<li><p><code>Object.is()</code>：对比两值是否相等</p>
</li>
<li><p><code>Object.assign()</code>：合并对象(浅拷贝)，返回原对象</p>
</li>
<li><p><code>Object.getPrototypeOf()</code>：返回对象的原型对象</p>
</li>
<li><p><code>Object.setPrototypeOf()</code>：设置对象的原型对象</p>
</li>
<li><p><code>proto</code>：返回或设置对象的原型对象</p>
</li>
<li><p><code>Object.getOwnPropertyDescriptors()</code>：返回对象所有自身属性(非继承属性)的描述对象</p>
</li>
<li><p><code>Object.values()</code>：返回以值组成的数组</p>
</li>
<li><p><code>Object.entries()</code>：返回以键和值组成的数组</p>
</li>
<li><p><code>Object.fromEntries()</code>：返回以键和值组成的对象(<code>Object.entries()</code>的逆操作)</p>
</li>
<li><p>属性遍历</p>
<ol>
<li><p>描述</p>
<ol>
<li><p>自身</p>
</li>
<li><p>可继承</p>
</li>
<li><p>可枚举</p>
</li>
<li><p>非枚举</p>
</li>
<li><p><code>Symbol</code></p>
</li>
</ol>
</li>
<li><p>遍历</p>
<ol>
<li><p><code>for-in</code>：遍历对象<strong>自身可继承可枚举</strong>属性</p>
</li>
<li><p><code>Object.keys()</code>：返回对象<strong>自身可枚举</strong>属性键组成的数组</p>
</li>
<li><p><code>Object.getOwnPropertyNames()</code>：返回对象<strong>自身非Symbol</strong>属性键组成的数组</p>
</li>
<li><p><code>Object.getOwnPropertySymbols()</code>：返回对象<strong>自身Symbol</strong>属性键组成的数组</p>
</li>
<li><p><code>Reflect.ownKeys()</code>：返回对象<strong>自身全部</strong>属性键组成的数组</p>
</li>
</ol>
</li>
<li><p>规则</p>
<ol>
<li><p>首先遍历所有数值键，按照数值升序排列</p>
</li>
<li><p>其次遍历所有字符串键，按照加入时间升序排列</p>
</li>
<li><p>最后遍历所有<code>Symbol</code>键，按照加入时间升序排列</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>扩展运算符(<code>...</code>)：转换对象为用逗号分隔的参数序列(<code>&#123; ...obj &#125;</code>，相当于<code>rest/spread</code>参数的逆运算)</p>
<ol>
<li><p>克隆对象：<code>const obj = &#123; __proto__: Object.getPrototypeOf(obj1), ...obj1 &#125;</code></p>
</li>
<li><p>合并对象：<code>const obj = &#123; ...obj1, ...obj2 &#125;</code></p>
</li>
<li><p>转换字符串为对象：<code>&#123; ...&quot;hello&quot; &#125;</code></p>
</li>
<li><p>转换数组为对象：<code>&#123; ...[1, 2] &#125;</code></p>
</li>
<li><p>与对象解构赋值结合：<code>const &#123; x, ...rest/spread &#125; = &#123; x: 1, y: 2, z: 3 &#125;</code>(不能复制继承自原型对象的属性)</p>
</li>
<li><p>修改现有对象部分属性：<code>const obj = &#123; x: 1, ...&#123; x: 2 &#125; &#125;</code></p>
</li>
</ol>
</li>
<li><p>&amp;#x20;链判断操作符(<code>?.</code>)：是否存在对象属性(不存在返回<code>undefined</code>且不再往下执行)</p>
<ol>
<li><p>对象属性：<code>obj?.prop</code>、<code>obj?.[expr]</code></p>
</li>
<li><p>函数调用：<code>func?.(...args)</code></p>
</li>
</ol>
</li>
<li><p>空判断操作符(<code>??</code>)：是否值为<code>undefined</code>或<code>null</code>，是则使用默认值</p>
</li>
</ol>
<h2 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h2><ol>
<li><p>扩展运算符(<code>...</code>)：转换数组为用逗号分隔的参数序列(<code>[...arr]</code>，相当于<code>rest/spread参数</code>的逆运算)</p>
</li>
<li><p><code>Array.from()</code></p>
<ol>
<li><p>转换具有<code>Iterator</code>接口的数据结构为真正数组，返回新数组</p>
</li>
<li><p>可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
</li>
<li><p>类数组对象：包含<code>length</code>的对象、<code>Arguments</code>对象、<code>NodeList</code>对象</p>
</li>
<li><p>可遍历对象：<code>String</code>、<code>Set</code>结构、<code>Map</code>结构、<code>Generator</code>函数</p>
</li>
</ol>
</li>
<li><p><code>Array.of()</code>：转换一组值为真正数组，返回新数组</p>
</li>
<li><p><code>copyWithin()</code>：把指定位置的成员复制到其他位置，返回原数组</p>
</li>
<li><p><code>find()</code>：返回第一个符合条件的成员</p>
</li>
<li><p><code>findIndex()</code>：返回第一个符合条件的成员索引值</p>
</li>
<li><p><code>fill()</code>：根据指定值填充整个数组，返回原数组</p>
</li>
<li><p><code>keys()</code>：返回以索引值为遍历器的对象</p>
</li>
<li><p><code>values()</code>：返回以属性值为遍历器的对象</p>
</li>
<li><p><code>entries()</code>：返回以索引值和属性值为遍历器的对象</p>
</li>
<li><p><code>includes()</code>：是否存在指定成员，返回布尔值</p>
</li>
<li><p><code>sort()</code>稳定性：排序关键字相同的项目其排序前后的顺序不变，默认为稳定</p>
</li>
<li><p><code>flat()</code>：扁平化数组，返回新数组，不改变原数组</p>
</li>
<li><p><code>flatMap()</code>：对原数组的每个成员执行一个函数，返回新数组(只能展开一层数组)，不改变原数组</p>
</li>
<li><p>数组空位：ES6明确将数组空位转为<code>undefined</code>(空位处理规不一，建议避免出现)</p>
</li>
<li><p>应用</p>
<ol>
<li><p>克隆数组：<code>const arr = [...arr1]</code></p>
</li>
<li><p>合并数组：<code>const arr = [...arr1, ...arr2]</code></p>
</li>
<li><p>拼接数组：<code>arr.push(...arr1)</code></p>
</li>
<li><p>代替<code>apply</code>：<code>Math.max.apply(null, [x, y])</code> → <code>Math.max(...[x, y])</code></p>
</li>
<li><p>转换字符串为数组：<code>[...&quot;hello&quot;]</code></p>
</li>
<li><p>转换类数组对象为数组：<code>[...Arguments, ...NodeList]</code></p>
</li>
<li><p>转换可遍历对象为数组：<code>[...String, ...Set, ...Map, ...Generator]</code></p>
</li>
<li><p>与数组解构赋值结合：<code>const [x, ...rest/spread] = [1, 2, 3]</code></p>
</li>
<li><p>计算<code>Unicode</code>字符长度：<code>Array.from(&quot;hello&quot;).length</code> → <code>[...&quot;hello&quot;].length</code></p>
</li>
</ol>
</li>
<li><p>注意</p>
<ul>
<li>使用<code>keys()</code>、<code>values()</code>、<code>entries()</code>返回的遍历器对象，可用<code>for-of</code>自动遍历或<code>next()</code>手动遍历</li>
</ul>
</li>
</ol>
<h2 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h2><ol>
<li><p>参数默认值：为函数参数指定默认值</p>
<ol>
<li><p>形式：<code>function Func(x = 1, y = 2) &#123;&#125;</code></p>
</li>
<li><p>参数赋值：惰性求值(函数调用后才求值)</p>
</li>
<li><p>参数位置：尾参数</p>
</li>
<li><p>参数作用域：函数作用域</p>
</li>
<li><p>声明方式：默认声明</p>
</li>
<li><p><code>length</code>：返回没有指定默认值的参数个数</p>
</li>
<li><p>与解构赋值默认值结合：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></p>
</li>
<li><p>注意</p>
<ol>
<li><p>使用参数默认值时，函数不能有同名参数</p>
</li>
<li><p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明</p>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>指定某个参数不得省略，省略即抛出错误：<code>function Func(x = throwMissing()) &#123;&#125;</code></p>
</li>
<li><p>将参数默认值设为<code>undefined</code>，表明此参数可省略：<code>Func(undefined, 1)</code></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><code>rest/spread</code>参数(<code>...</code>**)**：返回函数多余参数</p>
<ol>
<li><p>形式：以数组的形式存在，之后不能再有其他参数</p>
</li>
<li><p>作用：代替<code>Arguments</code>对象</p>
</li>
<li><p><code>length</code>：返回没有指定默认值的参数个数但不包括<code>rest/spread参数</code></p>
</li>
</ol>
</li>
<li><p>函数参数尾逗号：允许函数最后一个参数有尾逗号</p>
</li>
<li><p>严格模式</p>
<ol>
<li>应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</li>
</ol>
</li>
<li><p><code>name</code>属性：返回函数的函数名</p>
<ol>
<li><p>将匿名函数赋值给变量：<code>空字符串</code>(ES5)、<code>变量名</code>(ES6)</p>
</li>
<li><p>将具名函数赋值给变量：<code>函数名</code>(ES5和ES6)</p>
</li>
<li><p><code>bind</code>返回的函数：<code>bound 函数名</code>(ES5和ES6)</p>
</li>
<li><p><code>Function</code>构造函数返回的函数实例：<code>anonymous</code>(ES5和ES6)</p>
</li>
</ol>
</li>
<li><p><code>toString()</code>改造：返回函数原始代码(与编码一致)</p>
</li>
<li><p><code>catch()</code>参数可省略：<code>catch()</code>中的参数可省略</p>
</li>
<li><p>箭头函数 **(<strong><code>=&gt;</code></strong>) **：函数简写</p>
<ol>
<li><p>无参数：<code>() =&gt; &#123;&#125;</code></p>
</li>
<li><p>单个参数：<code>x =&gt; &#123;&#125;</code></p>
</li>
<li><p>多个参数：<code>(x, y) =&gt; &#123;&#125;</code></p>
</li>
<li><p>解构参数：<code>(&#123;x, y&#125;) =&gt; &#123;&#125;</code></p>
</li>
<li><p>嵌套使用：部署管道机制</p>
</li>
<li><p><code>this</code>指向固定化</p>
<ol>
<li><p>并非因为内部有绑定<code>this</code>的机制，而是根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code></p>
</li>
<li><p>因为没有<code>this</code>，因此不能用作构造函数</p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>函数体内的<code>this</code>是<code>定义时所在的对象</code>而不是<code>使用时所在的对象</code></p>
</li>
<li><p>可让<code>this</code>指向固定化，这种特性很有利于封装回调函数</p>
</li>
<li><p>不可当作<code>构造函数</code>，因此箭头函数不可使用<code>new</code>命令</p>
</li>
<li><p>不可使用<code>yield</code>命令，因此箭头函数不能用作<code>Generator</code>函数</p>
</li>
<li><p>不可使用<code>Arguments</code>对象，此对象在函数体内不存在(可用<code>rest/spread</code>参数代替)</p>
</li>
<li><p>返回对象时必须在对象外面加上括号</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>尾调用优化：只保留内层函数的调用帧</p>
<ul>
<li><p>尾调用</p>
<ul>
<li><p>定义：某个函数的最后一步是调用另一个函数</p>
</li>
<li><p>形式：<code>function f(x) &#123; return g(x); &#125;</code></p>
</li>
</ul>
</li>
<li><p>尾递归</p>
<ul>
<li><p>定义：函数尾调用自身</p>
</li>
<li><p>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</p>
</li>
<li><p>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h2><ol>
<li><p>变更<code>RegExp</code>构造函数入参：允许首参数为正则对象，尾参数为正则修饰符(返回的正则表达式会忽略原正则表达式的修饰符)</p>
</li>
<li><p>正则方法调用变更：字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></p>
</li>
<li><p><code>u</code>修饰符：<code>Unicode</code>模式修饰符，正确处理<code>\uFFFF</code>的<code>Unicode字符</code></p>
<ul>
<li><p>点字符(<code>.</code>)</p>
</li>
<li><p><code>Unicode</code>表示法</p>
</li>
<li><p>量词</p>
</li>
<li><p>预定义模式</p>
</li>
<li><p><code>i</code>修饰符</p>
</li>
<li><p>转义</p>
</li>
</ul>
</li>
<li><p><code>y</code>修饰符：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与<code>g</code>修饰符作用类似)</p>
</li>
<li><p><code>s</code>修饰符：<code>dotAll</code>模式修饰符，使<code>.</code>匹配任意单个字符(<code>dotAll</code>模式)</p>
</li>
<li><p><code>dotAll</code>：是否设置<code>s</code>修饰符</p>
</li>
<li><p><code>unicode</code>：是否设置<code>u</code>修饰符</p>
</li>
<li><p><code>Unicode</code>属性转义：匹配符合<code>Unicode</code>某种属性的所有字符</p>
<ul>
<li><p>正向匹配：<code>\p&#123;PropRule&#125;</code></p>
</li>
<li><p>反向匹配：<code>\P&#123;PropRule&#125;</code></p>
</li>
<li><p>限制：<code>\p&#123;...&#125;</code>和<code>\P&#123;...&#125;</code>只对<code>Unicode</code>字符有效，使用时需加上<code>u</code>修饰符</p>
</li>
</ul>
</li>
<li><p><code>sticky</code>：是否设置<code>y</code>修饰符</p>
</li>
<li><p><code>flags</code>：返回正则表达式的修饰符</p>
</li>
<li><p><code>matchAll()</code>：返回所有匹配的遍历器</p>
</li>
<li><p>后行断言：<code>x</code>只有在<code>y</code>后才匹配</p>
</li>
<li><p>后行否定断言：<code>x</code>只有不在<code>y</code>后才匹配</p>
</li>
<li><p>具名组匹配：为每组匹配指定名字(<code>?&lt;GroupName&gt;</code>)</p>
<ol>
<li><p>形式：<code>str.exec().groups.GroupName</code></p>
</li>
<li><p>解构赋值替换</p>
<ol>
<li><p>声明：<code>const time = &quot;2017-09-11&quot;</code>、<code>const regexp = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</code></p>
</li>
<li><p>匹配：<code>time.replace(regexp, &quot;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&quot;)</code></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><ol>
<li><p>定义：独一无二的值</p>
</li>
<li><p>声明：<code>const set = Symbol(str)</code></p>
</li>
<li><p>入参：字符串(可选)</p>
</li>
<li><p>方法</p>
<ol>
<li><p><code>Symbol()</code>：创建以参数作为描述的<code>Symbol值</code>(不登记在全局环境)</p>
</li>
<li><p><code>Symbol.for()</code>：创建以参数作为描述的<code>Symbol值</code>，如存在此参数则返回原有的<code>Symbol值</code>(先搜索后创建，登记在全局环境)</p>
</li>
<li><p><code>Symbol.keyFor()</code>：返回已登记的<code>Symbol值</code>的描述(只能返回<code>Symbol.for()</code>的<code>key</code>)</p>
</li>
<li><p><code>Object.getOwnPropertySymbols()</code>：返回对象中所有用作属性名的<code>Symbol值</code>的数组</p>
</li>
</ol>
</li>
<li><p>内置</p>
<ol>
<li><p><code>Symbol.hasInstance</code>：指向一个内部方法，当其他对象使用<code>instanceof</code>运算符判断是否为此对象的实例时会调用此方法</p>
</li>
<li><p><code>Symbol.isConcatSpreadable</code>：指向一个布尔值，定义对象用于<code>Array.prototype.concat()</code>时是否可展开</p>
</li>
<li><p><code>Symbol.species</code>：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</p>
</li>
<li><p><code>Symbol.match</code>：指向一个函数，当实例对象被<code>String.prototype.match()</code>调用时会重新定义<code>match()</code>的行为</p>
</li>
<li><p><code>Symbol.replace</code>：指向一个函数，当实例对象被<code>String.prototype.replace()</code>调用时会重新定义<code>replace()</code>的行为</p>
</li>
<li><p><code>Symbol.search</code>：指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义<code>search()</code>的行为</p>
</li>
<li><p><code>Symbol.split</code>：指向一个函数，当实例对象被<code>String.prototype.split()</code>调用时会重新定义<code>split()</code>的行为</p>
</li>
<li><p><code>Symbol.iterator</code>：指向一个默认遍历器方法，当实例对象执行<code>for-of</code>时会调用指定的默认遍历器</p>
</li>
<li><p><code>Symbol.toPrimitive</code>：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</p>
</li>
<li><p><code>Symbol.toStringTag</code>：指向一个函数，当实例对象被<code>Object.prototype.toString()</code>调用时其返回值会出现在<code>toString()</code>返回的字符串之中表示对象的类型</p>
</li>
<li><p><code>Symbol.unscopables</code>：指向一个对象，指定使用<code>with</code>时哪些属性会被<code>with环境</code>排除</p>
</li>
</ol>
</li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ol>
<li><p>定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</p>
</li>
<li><p>声明：<code>const set = new Set(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator</code>接口的数据结构</p>
</li>
<li><p>属性</p>
<ol>
<li><p><code>constructor</code>：构造函数，返回Set</p>
</li>
<li><p><code>size</code>：返回实例成员总数</p>
</li>
</ol>
</li>
<li><p>方法</p>
<ul>
<li><p><code>add()</code>：添加值，返回实例</p>
</li>
<li><p><code>delete()</code>：删除值，返回布尔值</p>
</li>
<li><p><code>has()</code>：检查值，返回布尔值</p>
</li>
<li><p><code>clear()</code>：清除所有成员</p>
</li>
<li><p><code>keys()</code>：返回以属性值为遍历器的对象</p>
</li>
<li><p><code>values()</code>：返回以属性值为遍历器的对象</p>
</li>
<li><p><code>entries()</code>：返回以属性值和属性值为遍历器的对象</p>
</li>
<li><p><code>forEach()</code>：使用回调函数遍历每个成员</p>
</li>
</ul>
</li>
<li><p>应用</p>
<ol>
<li><p>去重字符串：<code>[...new Set(str)].join(&quot;&quot;)</code></p>
</li>
<li><p>去重数组：<code>[...new Set(arr)]</code>或<code>Array.from(new Set(arr))</code></p>
</li>
<li><p>集合数组</p>
<ol>
<li><p>声明：<code>const a = new Set(arr1)</code>、<code>const b = new Set(arr2)</code></p>
</li>
<li><p>并集：<code>new Set([...a, ...b])</code></p>
</li>
<li><p>交集：<code>new Set([...a].filter(v =&gt; b.has(v)))</code></p>
</li>
<li><p>差集：<code>new Set([...a].filter(v =&gt; !b.has(v)))</code></p>
</li>
</ol>
</li>
<li><p>映射集合</p>
<ol>
<li><p>声明：<code>let set = new Set(arr)</code></p>
</li>
<li><p>映射：<code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>遍历顺序：插入顺序</p>
</li>
<li><p>没有键只有值，可认为键和值两值相等</p>
</li>
<li><p>添加多个<code>NaN</code>时，只会存在一个<code>NaN</code></p>
</li>
<li><p>添加相同的对象时，会认为是不同的对象</p>
</li>
<li><p>添加值时不会发生类型转换(<code>5 !== &quot;5&quot;</code>)</p>
</li>
<li><p><code>keys()</code>和<code>values()</code>的行为完全一致，<code>entries()</code>返回的遍历器同时包括键和值且两值相等</p>
</li>
</ol>
</li>
</ol>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><ol>
<li><p>定义：和<code>Set</code>结构类似，成员值只能是对象</p>
</li>
<li><p>声明：<code>const set = new WeakSet(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator</code>接口的数据结构</p>
</li>
<li><p>属性</p>
<ul>
<li><code>constructor</code>：构造函数，返回<code>WeakSet</code></li>
</ul>
</li>
<li><p>方法</p>
<ol>
<li><p><code>add()</code>：添加值，返回实例</p>
</li>
<li><p><code>delete()</code>：删除值，返回布尔值</p>
</li>
<li><p><code>has()</code>：检查值，返回布尔值</p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>成员都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakSet</code>结构对此成员的引用</p>
</li>
<li><p>成员不适合引用，它会随时消失，因此ES6规定<code>WeakSet</code>结构不可遍历</p>
</li>
<li><p>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakSet</code>结构中</p>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>储存<code>DOM</code>节点：<code>DOM</code>节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</p>
</li>
<li><p>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在<code>WeakSet</code>结构中的引用就会自动消</p>
</li>
</ol>
</li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol>
<li><p>定义：类似于对象的数据结构，成员键是任何类型的值</p>
</li>
<li><p>声明：<code>const set = new Map(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator</code>接口且每个成员都是一个双元素数组的数据结构</p>
</li>
<li><p>属性</p>
<ol>
<li><p><code>constructor</code>：构造函数，返回<code>Map</code></p>
</li>
<li><p><code>size</code>：返回实例成员总数</p>
</li>
</ol>
</li>
<li><p>方法</p>
<ol>
<li><p><code>get()</code>：返回键值对</p>
</li>
<li><p><code>set()</code>：添加键值对，返回实例</p>
</li>
<li><p><code>delete()</code>：删除键值对，返回布尔值</p>
</li>
<li><p><code>has()</code>：检查键值对，返回布尔值</p>
</li>
<li><p><code>clear()</code>：清除所有成员</p>
</li>
<li><p><code>keys()</code>：返回以键为遍历器的对象</p>
</li>
<li><p><code>values()</code>：返回以值为遍历器的对象</p>
</li>
<li><p><code>entries()</code>：返回以键和值为遍历器的对象</p>
</li>
<li><p><code>forEach()</code>：使用回调函数遍历每个成员</p>
</li>
</ol>
</li>
</ol>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><ol>
<li><p>定义：和<code>Map</code>结构类似，成员键只能是对象</p>
</li>
<li><p>声明：<code>const set = new WeakMap(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator</code>接口且每个成员都是一个双元素数组的数据结构</p>
</li>
<li><p>属性</p>
<ul>
<li><code>constructor</code>：构造函数，返回<code>WeakMap</code></li>
</ul>
</li>
<li><p>方法</p>
<ol>
<li><p><code>get()</code>：返回键值对</p>
</li>
<li><p><code>set()</code>：添加键值对，返回实例</p>
</li>
<li><p><code>delete()</code>：删除键值对，返回布尔值</p>
</li>
<li><p><code>has()</code>：检查键值对，返回布尔值</p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>成员键都是弱引用，垃圾回收机制不考虑<code>WeakMap</code>结构对此成员键的引用</p>
</li>
<li><p>成员键不适合引用，它会随时消失，因此ES6规定<code>WeakMap</code>结构不可遍历</p>
</li>
<li><p>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap</code>结构中</p>
</li>
<li><p>一旦不再需要，成员会自动消失，不用手动删除引用</p>
</li>
<li><p>弱引用的只是键而不是值，值依然是正常引用</p>
</li>
<li><p>即使在外部消除了成员键的引用，内部的成员值依然存在</p>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>储存<code>DOM</code>节点：<code>DOM</code>节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</p>
</li>
<li><p>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</p>
</li>
</ol>
</li>
</ol>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><ol>
<li><p>修改某些操作的默认行为</p>
</li>
<li><p>声明：<code>const proxy = new Proxy(target, handler)</code></p>
</li>
<li><p>入参</p>
<ol>
<li><p><code>target</code>：拦截的目标对象</p>
</li>
<li><p><code>handler</code>：定制拦截行为</p>
</li>
</ol>
</li>
<li><p>方法</p>
<ul>
<li><code>Proxy.revocable()</code>：返回可取消的<code>Proxy</code>实例(返回<code>&#123; proxy, revoke &#125;</code>，通过<code>revoke()</code>取消代理)</li>
</ul>
</li>
<li><p>拦截方式</p>
<ol>
<li><p><code>get()</code>：拦截对象属性读取</p>
</li>
<li><p><code>set()</code>：拦截对象属性设置，返回布尔值</p>
</li>
<li><p><code>has()</code>：拦截对象属性检查<code>k in obj</code>，返回布尔值</p>
</li>
<li><p><code>deleteProperty()</code>：拦截对象属性删除<code>delete obj[k]</code>，返回布尔值</p>
</li>
<li><p><code>defineProperty()</code>：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔值</p>
</li>
<li><p><code>ownKeys()</code>：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>，返回数组</p>
</li>
<li><p><code>getOwnPropertyDescriptor()</code>：拦截对象属性描述读取<code>Object.getOwnPropertyDescriptor()</code>，返回对象</p>
</li>
<li><p><code>getPrototypeOf()</code>：拦截对象原型读取<code>instanceof</code>、<code>Object.getPrototypeOf()</code>、<code>Object.prototype.__proto__</code>、<code>Object.prototype.isPrototypeOf()</code>、<code>Reflect.getPrototypeOf()</code>，返回对象</p>
</li>
<li><p><code>setPrototypeOf()</code>：拦截对象原型设置<code>Object.setPrototypeOf()</code>，返回布尔值</p>
</li>
<li><p><code>isExtensible()</code>：拦截对象是否可扩展读取<code>Object.isExtensible()</code>，返回布尔值</p>
</li>
<li><p><code>preventExtensions()</code>：拦截对象不可扩展设置<code>Object.preventExtensions()</code>，返回布尔值</p>
</li>
<li><p><code>apply()</code>：拦截Proxy实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></p>
</li>
<li><p><code>construct()</code>：拦截Proxy实例作为构造函数调用<code>new proxy()</code></p>
</li>
<li><p>注意</p>
<ol>
<li><p>要使<code>Proxy</code>起作用，必须针对实例进行操作，而不是针对目标对象进行操作</p>
</li>
<li><p>没有设置任何拦截时，等同于直接通向原对象</p>
</li>
<li><p>属性被定义为不可读写&#x2F;扩展&#x2F;配置&#x2F;枚举时，使用拦截方法会报错</p>
</li>
<li><p>代理下的目标对象，内部<code>this</code>指向<code>Proxy</code>代理</p>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p><code>Proxy.revocable()</code>：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</p>
</li>
<li><p><code>get()</code>：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成<code>DOM</code>嵌套节点</p>
</li>
<li><p><code>set()</code>：数据绑定(<code>Vue</code>数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</p>
</li>
<li><p><code>has()</code>：隐藏内部属性不被发现、排除不符合属性条件的对象</p>
</li>
<li><p><code>deleteProperty()</code>：保护内部属性不被删除</p>
</li>
<li><p><code>defineProperty()</code>：阻止属性被外部定义</p>
</li>
<li><p><code>ownKeys()</code>：保护内部属性不被遍历</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><ol>
<li><p>定义：保持<code>Object</code>方法的默认行为</p>
</li>
<li><p>方法</p>
<ol>
<li><p><code>get()</code>：返回对象属性</p>
</li>
<li><p><code>set()</code>：设置对象属性，返回布尔值</p>
</li>
<li><p><code>has()</code>：检查对象属性，返回布尔值</p>
</li>
<li><p><code>deleteProperty()</code>：删除对象属性，返回布尔值</p>
</li>
<li><p><code>defineProperty()</code>：定义对象属性，定义的属性默认是不可枚举，返回布尔值</p>
</li>
<li><p><code>ownKeys()</code>：遍历对象属性，返回数组(<code>Object.getOwnPropertyNames()</code>+<code>Object.getOwnPropertySymbols()</code>)</p>
</li>
<li><p><code>getOwnPropertyDescriptor()</code>：返回对象属性描述，返回对象</p>
</li>
<li><p><code>getPrototypeOf()</code>：返回对象原型，返回对象</p>
</li>
<li><p><code>setPrototypeOf()</code>：设置对象原型，返回布尔值</p>
</li>
<li><p><code>isExtensible()</code>：返回对象是否可扩展，返回布尔值</p>
</li>
<li><p><code>preventExtensions()</code>：设置对象不可扩展，返回布尔值</p>
</li>
<li><p><code>apply()</code>：绑定this后执行指定函数</p>
</li>
<li><p><code>construct()</code>：调用构造函数创建实例</p>
</li>
</ol>
</li>
</ol>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ol>
<li><p>定义：对一类具有共同特征的事物的抽象(构造函数语法糖)</p>
</li>
<li><p>原理：类本身指向构造函数，所有方法定义在<code>prototype</code>上，可看作构造函数的另一种写法(<code>Class === Class.prototype.constructor</code>)</p>
</li>
<li><p>方法和关键字</p>
<ol>
<li><p><code>constructor()</code>：构造函数，<code>new</code>命令生成实例时自动调用</p>
</li>
<li><p><code>extends</code>：继承父类</p>
</li>
<li><p><code>super</code>：新建父类的<code>this</code></p>
</li>
<li><p><code>static</code>：定义静态属性方法</p>
</li>
<li><p><code>get</code>：取值函数，拦截属性的取值行为</p>
</li>
<li><p><code>set</code>：存值函数，拦截属性的存值行为</p>
</li>
</ol>
</li>
<li><p>属性</p>
<ol>
<li><p><code>proto</code>：构造函数的继承(总是指向父类)</p>
</li>
<li><p><code>proto.proto</code>：子类的原型的原型，即父类的原型(总是指向父类的<code>__proto__</code>)</p>
</li>
<li><p><code>prototype.proto</code>：属性方法的继承(总是指向父类的<code>prototype</code>)</p>
</li>
</ol>
</li>
<li><p>静态属性：定义类完成后赋值属性，该属性不会被实例继承，只能通过类来调用</p>
</li>
<li><p>静态方法：使用<code>static</code>定义方法，该方法不会被实例继承，只能通过类来调用(方法中的<code>this</code>指向类，而不是实例)</p>
</li>
<li><p>继承</p>
<ol>
<li><p>实质</p>
<ol>
<li><p>ES5实质：先创造子类实例的<code>this</code>，再将父类的属性方法添加到<code>this</code>上(<code>Parent.apply(this)</code>)</p>
</li>
<li><p>ES6实质：先将父类实例的属性方法加到<code>this</code>上(调用<code>super()</code>)，再用子类构造函数修改<code>this</code></p>
</li>
</ol>
</li>
<li><p><code>super</code></p>
<ol>
<li><p>作为函数调用：只能在构造函数中调用<code>super()</code>，内部<code>this</code>指向继承的当前子类(<code>super()</code>调用后才可在构造函数中使用<code>this</code>)</p>
</li>
<li><p>作为对象调用：在普通方法中指向父类的原型对象，在静态方法中指向父类</p>
</li>
</ol>
</li>
<li><p>显示定义：使用<code>constructor() &#123; super(); &#125;</code>定义继承父类，没有书写则显示定义</p>
</li>
<li><p>子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用<code>super()</code>，否则得不到父类的<code>this</code></p>
<ol>
<li><p>父类静态属性方法可被子类继承</p>
</li>
<li><p>子类继承父类后，可从<code>super</code>上调用父类静态属性方法</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>实例：类相当于实例的原型，所有在类中定义的属性方法都会被实例继承</p>
<ol>
<li><p>显式指定属性方法：使用<code>this</code>指定到自身上(使用<code>Class.hasOwnProperty()</code>可检测到)</p>
</li>
<li><p>隐式指定属性方法：直接声明定义在对象原型上(使用<code>Class.__proto__.hasOwnProperty()</code>可检测到)</p>
</li>
</ol>
</li>
<li><p><code>this</code>指向：解构实例属性或方法时会报错</p>
</li>
<li><p>属性定义位置</p>
<ol>
<li><p>定义在构造函数中并使用<code>this</code>指向</p>
</li>
<li><p>定义在类最顶层</p>
</li>
</ol>
</li>
<li><p><code>new.target</code>：确定构造函数是如何调用</p>
</li>
<li><p>注意</p>
<ol>
<li><p>在实例上调用方法，实质是调用原型上的方法</p>
</li>
<li><p><code>Object.assign()</code>可方便地一次向类添加多个方法(<code>Object.assign(Class.prototype, &#123; ... &#125;)</code>)</p>
</li>
<li><p>类内部所有定义的方法是不可枚举的(<code>non-enumerable</code>)</p>
</li>
<li><p>构造函数默认返回实例对象(<code>this</code>)，可指定返回另一个对象</p>
</li>
<li><p>取值函数和存值函数设置在属性的<code>Descriptor</code>对象上</p>
</li>
<li><p>类不存在变量提升</p>
</li>
<li><p>利用<code>new.target === Class</code>写出不能独立使用必须继承后才能使用的类</p>
</li>
<li><p>子类继承父类后，<code>this</code>指向子类实例，通过<code>super</code>对某个属性赋值，赋值的属性会变成子类实例的属性</p>
</li>
<li><p>使用<code>super</code>时，必须显式指定是作为函数还是作为对象使用</p>
</li>
<li><p><code>extends</code>不仅可继承类还可继承原生的构造函数</p>
</li>
</ol>
</li>
</ol>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><ol>
<li><p>命令</p>
<ol>
<li><p><code>export</code>：规定模块对外接口</p>
<ol>
<li><p>默认导出：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</p>
</li>
<li><p>单独导出：<code>export const name = &quot;Bruce&quot;</code></p>
</li>
<li><p>按需导出：<code>export &#123; age, name, sex &#125;</code>(推荐)</p>
</li>
<li><p>改名导出：<code>export &#123; name as newName &#125;</code></p>
</li>
</ol>
</li>
<li><p><code>import</code>：导入模块内部功能</p>
<ol>
<li><p>默认导入：<code>import Person from &quot;person&quot;</code></p>
</li>
<li><p>整体导入：<code>import * as Person from &quot;person&quot;</code></p>
</li>
<li><p>按需导入：<code>import &#123; age, name, sex &#125; from &quot;person&quot;</code></p>
</li>
<li><p>改名导入：<code>import &#123; name as newName &#125; from &quot;person&quot;</code></p>
</li>
<li><p>自执导入：<code>import &quot;person&quot;</code></p>
</li>
<li><p>复合导入：<code>import Person, &#123; name &#125; from &quot;person&quot;</code></p>
</li>
</ol>
</li>
<li><p>复合模式：<code>export</code>命令和<code>import</code>命令结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量</p>
<ol>
<li><p>默认导入导出：<code>export &#123; default &#125; from &quot;person&quot;</code></p>
</li>
<li><p>整体导入导出：<code>export * from &quot;person&quot;</code></p>
</li>
<li><p>按需导入导出：<code>export &#123; age, name, sex &#125; from &quot;person&quot;</code></p>
</li>
<li><p>改名导入导出：<code>export &#123; name as newName &#125; from &quot;person&quot;</code></p>
</li>
<li><p>具名改默认导入导出：<code>export &#123; name as default &#125; from &quot;person&quot;</code></p>
</li>
<li><p>默认改具名导入导出：<code>export &#123; default as name &#125; from &quot;person&quot;</code></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>继承：默认导出和改名导出结合使用可使模块具备继承性</p>
</li>
<li><p>设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
</li>
<li><p>严格模式：ES6模块自动采用严格模式(不管模块头部是否添加<code>use strict</code>)</p>
</li>
<li><p>模块方案</p>
<ol>
<li><p><code>CommonJS</code>：用于服务器(动态化依赖)</p>
</li>
<li><p><code>AMD</code>：用于浏览器(动态化依赖)</p>
</li>
<li><p><code>CMD</code>：用于浏览器(动态化依赖)</p>
</li>
<li><p><code>UMD</code>：用于浏览器和服务器(动态化依赖)</p>
</li>
<li><p><code>ESM</code>：用于浏览器和服务器(静态化依赖)</p>
</li>
</ol>
</li>
<li><p>加载方式</p>
<ol>
<li><p>运行时加载</p>
<ol>
<li><p>定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)</p>
</li>
<li><p>影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化</p>
</li>
</ol>
</li>
<li><p>编译时加载</p>
<ol>
<li><p>定义：直接从模块中获取需要的属性和方法进行加载(按需加载)</p>
</li>
<li><p>影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(本身不是对象)，可拓展JS高级语法(宏和类型校验)</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>加载实现</p>
<ol>
<li><p>传统加载：通过<code>&lt;script&gt;</code>进行同步或异步加载脚本</p>
<ol>
<li><p>同步加载：<code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li><p><code>Defer</code>异步加载：<code>&lt;script src=&quot;&quot; defer&gt;&lt;/script&gt;</code>(顺序加载，渲染完再执行)</p>
</li>
<li><p><code>Async</code>异步加载：<code>&lt;script src=&quot;&quot; async&gt;&lt;/script&gt;</code>(乱序加载，下载完就执行)</p>
</li>
</ol>
</li>
<li><p>模块加载：<code>&lt;script type=&quot;module&quot; src=&quot;&quot;&gt;&lt;/script&gt;</code>(默认是<code>Defer</code>异步加载)</p>
</li>
</ol>
</li>
<li><p><code>CommonJS</code>和<code>ESM</code>的区别</p>
<ol>
<li><p><code>CommonJS</code>输出值的拷贝，<code>ESM</code>输出值的引用</p>
<ol>
<li><p><code>CommonJS</code>一旦输出一个值，模块内部的变化就影响不到这个值</p>
</li>
<li><p><code>ESM</code>是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值</p>
</li>
</ol>
</li>
<li><p><code>CommonJS</code>是运行时加载，<code>ESM</code>是编译时加载</p>
<ol>
<li><p><code>CommonJS</code>加载模块是对象(即<code>module.exports</code>)，该对象只有在脚本运行完才会生成</p>
</li>
<li><p><code>ESM</code>加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>循环加载</p>
<ol>
<li><p>定义：脚本A的执行依赖脚本B，而脚本A的执行又依赖脚本B</p>
</li>
<li><p>加载原理</p>
<ol>
<li><p><code>CommonJS</code>：<code>require()</code>首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取</p>
</li>
<li><p><code>ESM</code>：<code>import</code>命令加载变量不会被缓存，而是成为一个指向被加载模块的引用</p>
</li>
</ol>
</li>
<li><p>循环加载</p>
<ol>
<li><p><code>CommonJS</code>：只输出已经执行的部分，还未执行的部分不会输出</p>
</li>
<li><p><code>ESM</code>：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><code>import()</code>：动态导入(返回<code>Promise</code>)</p>
<ol>
<li><p>背景：<code>import</code>命令被JS引擎静态分析，先于模块内的其他语句执行，无法取代<code>require()</code>的动态加载功能，提案建议引入<code>import()</code>来代替<code>require()</code></p>
</li>
<li><p>位置：可在任何地方使用</p>
</li>
<li><p>区别：<code>require()</code>是同步加载，<code>import()</code>是异步加载</p>
</li>
<li><p>场景：按需加载、条件加载、模块路径动态化</p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p><code>ES6</code>模块中，顶层<code>this</code>指向<code>undefined</code>，不应该在顶层代码使用<code>this</code></p>
</li>
<li><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取</p>
</li>
<li><p><code>export</code>命令输出的接口与其对应的值是动态绑定关系，即通过该接口可获取模块内部实时的值</p>
</li>
<li><p><code>import</code>命令大括号里的变量名必须与被导入模块对外接口的名称相同</p>
</li>
<li><p><code>import</code>命令输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口</p>
</li>
<li><p><code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行</p>
</li>
<li><p>重复执行同一句<code>import</code>语句，只会执行一次</p>
</li>
<li><p><code>export default</code>命令只能使用一次</p>
</li>
<li><p><code>export default</code>命令导出的整体模块，在执行<code>import</code>命令时其后不能跟大括号</p>
</li>
<li><p><code>export default</code>命令本质是输出一个名为<code>default</code>的变量，后面不能跟变量声明语句</p>
</li>
<li><p><code>export default</code>命令本质是将后面的值赋给名为<code>default</code>的变量，可直接将值写在其后</p>
</li>
<li><p><code>export default</code>命令和<code>export &#123;&#125;</code>命令可同时存在，对应复合导入</p>
</li>
<li><p><code>export</code>命令和<code>import</code>命令可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域</p>
</li>
<li><p><code>import()</code>加载模块成功后，此模块会作为一个对象，当作<code>then()</code>的参数，可使用对象解构赋值来获取输出接口</p>
</li>
<li><p>同时动态加载多个模块时，可使用<code>Promise.all()</code>和<code>import()</code>相结合来实现</p>
</li>
<li><p><code>import()</code>和结合<code>async/await</code>来书写同步操作的代码</p>
</li>
</ol>
</li>
</ol>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><ol>
<li><p>定义：为各种不同的数据结构提供统一的访问机制</p>
</li>
<li><p>原理：创建一个指针指向首个成员，按照次序使用<code>next()</code>指向下一个成员，直接到结束位置(数据结构只要部署<code>Iterator</code>接口就可完成遍历操作)</p>
</li>
<li><p>作用</p>
<ol>
<li><p>为各种数据结构提供一个统一的简便的访问接口</p>
</li>
<li><p>使得数据结构成员能够按某种次序排列</p>
</li>
<li><p><code>ES6</code>创造了新的遍历命令<code>for-of</code>，<code>Iterator</code>接口主要供<code>for-of</code>消费</p>
</li>
</ol>
</li>
<li><p>形式：<code>for-of</code>(自动去寻找<code>Iterator</code>接口)</p>
</li>
<li><p>数据结构</p>
<ol>
<li><p>集合：<code>Array</code>、<code>Object</code>、<code>Set</code>、<code>Map</code></p>
</li>
<li><p>原生具备接口的数据结构：<code>String</code>、<code>Array</code>、<code>Set</code>、<code>Map</code>、<code>TypedArray</code>、<code>Arguments</code>、<code>NodeList</code></p>
</li>
</ol>
</li>
<li><p>部署：默认部署在<code>Symbol.iterator</code>(具备此属性被认为可遍历的<code>iterable</code>)</p>
</li>
<li><p>遍历器对象</p>
<ol>
<li><p><code>next()</code>：下一步操作，返回<code>&#123; done, value &#125;</code>(必须部署)</p>
</li>
<li><p><code>return()</code>：<code>for-of</code>提前退出调用，返回<code>&#123; done: true &#125;</code></p>
</li>
<li><p><code>throw()</code>：不使用，配合<code>Generator</code>函数使用</p>
</li>
</ol>
</li>
<li><p><code>for-of</code>循环</p>
<ol>
<li><p>定义：调用<code>Iterator</code>接口产生遍历器对象(<code>for-of</code>内部调用数据结构的<code>Symbol.iterator()</code>)</p>
</li>
<li><p>遍历字符串：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code>(可识别32位<code>UTF-16</code>字符)</p>
</li>
<li><p>遍历数组：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code></p>
</li>
<li><p>遍历对象：<code>for-in</code>获取<code>键</code>，<code>for-of</code>需自行部署</p>
</li>
<li><p>遍历<code>Set</code>：<code>for-of</code>获取<code>值</code> &#x3D;&gt; <code>for (const v of set)</code></p>
</li>
<li><p>遍历<code>Map</code>：<code>for-of</code>获取<code>键值对</code> &#x3D;&gt; <code>for (const [k, v] of map)</code></p>
</li>
<li><p>遍历类数组：包含<code>length</code>的对象、<code>Arguments</code>对象、<code>NodeList</code>对象(无<code>Iterator</code>接口的类数组可用<code>Array.from()</code>转换)</p>
</li>
<li><p>计算生成数据结构：<code>Array</code>、<code>Set</code>、<code>Map</code></p>
<ol>
<li><p><code>keys()</code>：返回遍历器对象，遍历所有的键</p>
</li>
<li><p><code>values()</code>：返回遍历器对象，遍历所有的值</p>
</li>
<li><p><code>entries()</code>：返回遍历器对象，遍历所有的键值对</p>
</li>
</ol>
</li>
<li><p>与<code>for-in</code>区别</p>
<ol>
<li><p>有着同<code>for-in</code>一样的简洁语法，但没有<code>for-in</code>那些缺点、</p>
</li>
<li><p>不同于<code>forEach()</code>，它可与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</p>
</li>
<li><p>提供遍历所有数据结构的统一操作接口</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>改写具有<code>Iterator</code>接口的数据结构的<code>Symbol.iterator</code></p>
</li>
<li><p>解构赋值：对<code>Set</code>进行解构</p>
</li>
<li><p>扩展运算符：将部署<code>Iterator</code>接口的数据结构转为数组</p>
</li>
<li><p><code>yield*</code>：<code>yield*</code>后跟一个可遍历的数据结构，会调用其遍历器接口</p>
</li>
<li><p>接受数组作为参数的函数：<code>for-of</code>、<code>Array.from()</code>、<code>new Set()</code>、<code>new WeakSet()</code>、<code>new Map()</code>、<code>new WeakMap()</code>、<code>Promise.all()</code>、<code>Promise.race()</code></p>
</li>
</ol>
</li>
</ol>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ol>
<li><p>定义：包含异步操作结果的对象</p>
</li>
<li><p>状态</p>
<ol>
<li><p>进行中：<code>pending</code></p>
</li>
<li><p>已成功：<code>resolved</code></p>
</li>
<li><p>已失败：<code>rejected</code></p>
</li>
</ol>
</li>
<li><p>特点</p>
<ol>
<li><p>对象的状态不受外界影响</p>
</li>
<li><p>一旦状态改变就不会再变，任何时候都可得到这个结果</p>
</li>
</ol>
</li>
<li><p>声明：<code>new Promise((resolve, reject) =&gt; &#123;&#125;)</code></p>
</li>
<li><p>出参</p>
<ol>
<li><p><code>resolve</code>：将状态从未完成变为成功，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</p>
</li>
<li><p><code>reject</code>：将状态从未完成变为失败，在异步操作失败时调用，并将异步操作的错误作为参数传递出去</p>
</li>
</ol>
</li>
<li><p>方法</p>
<ol>
<li><p><code>then()</code>：分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数</p>
<ol>
<li><p>第一参数：状态变为<code>resolved</code>时调用</p>
</li>
<li><p>第二参数：状态变为<code>rejected</code>时调用(可选)</p>
</li>
</ol>
</li>
<li><p><code>catch()</code>：指定发生错误时的回调函数</p>
</li>
<li><p><code>Promise.all()</code>：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)</p>
<ol>
<li><p>入参：具有<code>Iterator</code>接口的数据结构</p>
</li>
<li><p>成功：只有全部实例状态变成<code>fulfilled</code>，最终状态才会变成<code>fulfilled</code></p>
</li>
<li><p>失败：其中一个实例状态变成<code>rejected</code>，最终状态就会变成<code>rejected</code></p>
</li>
</ol>
</li>
<li><p><code>Promise.race()</code>：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)</p>
<ol>
<li><p>入参：具有<code>Iterator</code>接口的数据结构</p>
</li>
<li><p>成功失败：哪个实例率先改变状态就返回哪个实例的状态</p>
</li>
</ol>
</li>
<li><p><code>Promise.resolve()</code>：将对象转为Promise对象(等价于<code>new Promise(resolve =&gt; resolve())</code>)</p>
<ol>
<li><p><code>Promise</code>实例：原封不动地返回入参</p>
</li>
<li><p><code>Thenable</code>对象：将此对象转为<code>Promise</code>对象并返回(<code>Thenable</code>为包含<code>then()</code>的对象，执行<code>then()</code>相当于执行此对象的<code>then()</code>)</p>
</li>
<li><p>不具有<code>then()</code>的对象：将此对象转为<code>Promise</code>对象并返回，状态为<code>resolved</code></p>
</li>
<li><p>不带参数：返回<code>Promise</code>对象，状态为<code>resolved</code></p>
</li>
</ol>
</li>
<li><p><code>Promise.reject()</code>：将对象转为状态为<code>rejected</code>的<code>Promise</code>对象(等价于<code>new Promise((resolve, reject) =&gt; reject())</code>)</p>
</li>
<li><p><code>Promise.finally()</code>：指定不管最后状态如何都会执行的回调函数</p>
</li>
<li><p><code>Promise.allSettled()</code>：将多个实例包装成一个新实例，返回全部实例状态变更后的状态数组(齐变更再返回)</p>
<ol>
<li><p>入参：具有<code>Iterator</code>接口的数据结构</p>
</li>
<li><p>成功：成员包含<code>status</code>和<code>value</code>，<code>status</code>为<code>fulfilled</code>，<code>value</code>为返回值</p>
</li>
<li><p>失败：成员包含<code>status</code>和<code>reason</code>，<code>status</code>为<code>rejected</code>，<code>value</code>为错误原因</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><ol>
<li><p>定义：封装多个内部状态的异步编程解决方案</p>
</li>
<li><p>形式：调用<code>Generator</code>函数(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</p>
</li>
<li><p>声明：<code>function* Func() &#123;&#125;</code></p>
</li>
<li><p>方法</p>
<ol>
<li><p><code>next()</code>：使指针移向下一个状态，返回<code>&#123; done, value &#125;</code>(入参会被当作上一个<code>yield</code>命令表达式的返回值)</p>
</li>
<li><p><code>return()</code>：返回指定值且终结遍历<code>Generator</code>函数，返回<code>&#123; done: true, value: 入参 &#125;</code></p>
</li>
<li><p><code>throw()</code>：在<code>Generator</code>函数体外抛出错误，在<code>Generator</code>函数体内捕获错误，返回自定义的<code>new Errow()</code></p>
</li>
</ol>
</li>
<li><p><code>yield</code>命令：声明内部状态的值(<code>return</code>声明结束返回的值)</p>
<ol>
<li><p>遇到<code>yield</code>命令就暂停执行后面的操作，并将其后表达式的值作为返回对象的<code>value</code></p>
</li>
<li><p>下次调用<code>next()</code>时，再继续往下执行直到遇到下一个<code>yield</code>命令</p>
</li>
<li><p>没有再遇到<code>yield</code>命令就一直运行到<code>Generator</code>函数结束，直到遇到<code>return</code>语句为止并将其后表达式的值作为返回对象的<code>value</code></p>
</li>
<li><p><code>Generator</code>函数没有<code>return</code>语句<code>则返</code>回对象的<code>value</code>为<code>undefined</code></p>
</li>
</ol>
</li>
<li><p><code>yield*</code>命令：在一个<code>Generator</code>函数里执行另一个<code>Generator</code>函数(后随具有<code>Iterator</code>接口的数据结构)</p>
</li>
<li><p>遍历：通过<code>for-of</code>自动调用<code>next()</code></p>
</li>
<li><p>作为对象属性</p>
<ol>
<li><p>全写：<code>const obj = &#123; method: function*() &#123;&#125; &#125;</code></p>
</li>
<li><p>简写：<code>const obj = &#123; * method() &#123;&#125; &#125;</code></p>
</li>
</ol>
</li>
<li><p>上下文：执行产生的上下文环境一旦遇到<code>yield</code>命令就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在当前状态，等到对它执行<code>next()</code>时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行</p>
</li>
<li><p>方法异同</p>
<ol>
<li><p>相同点：<code>next()</code>、<code>throw()</code>、<code>return()</code>本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换<code>yield命令</code></p>
</li>
<li><p>不同点</p>
<ol>
<li><p><code>next()</code>：将<code>yield</code>命令替换成一个值</p>
</li>
<li><p><code>return()</code>：将<code>yield</code>命令替换成一个<code>return</code>语句</p>
</li>
<li><p><code>throw()</code>：将<code>yield</code>命令替换成一个<code>throw</code>语句</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>每次调用<code>next()</code>，指针就从函数头部或<code>上</code>次停下的位置开始执行，直到遇到下一个<code>yield</code>命令或<code>return</code>语句为止</p>
</li>
<li><p>函数内部可不用<code>yield</code>命令，但会变成单纯的暂缓执行函数(还是需要<code>next()</code>触发)</p>
</li>
<li><p><code>yield</code>命令是暂停执行的标记，<code>next()</code>是恢复执行的操作</p>
</li>
<li><p><code>yield</code>命令用在另一个表达式中必须放在圆括号里</p>
</li>
<li><p><code>yield</code>命令用作函数参数或放在赋值表达式的右边，可不加圆括号</p>
</li>
<li><p><code>yield</code>命令本身没有返回值，可认为是返回<code>undefined</code></p>
</li>
<li><p><code>yield</code>命令表达式为惰性求值，等<code>next()</code>执行到此才求值</p>
</li>
<li><p>函数调用后生成遍历器对象，此对象的<code>Symbol.iterator</code>是此对象本身</p>
</li>
<li><p>在函数运行的不同阶段，通过<code>next()</code>从外部向内部注入不同的值，从而调整函数行为</p>
</li>
<li><p>首个<code>next()</code>用来启动遍历器对象，后续才可传递参数</p>
</li>
<li><p>想首次调用<code>next()</code>时就能输入值，可在函数外面再包一层</p>
</li>
<li><p>一旦<code>next()</code>返回对象的<code>done</code>为<code>true</code>，<code>for-of</code>遍历会中止且不包含该返回对象</p>
</li>
<li><p>函数内部部署<code>try-finally</code>且正在执行<code>try</code>，那么<code>return()</code>会导致立刻进入<code>finally</code>，执行完<code>finally</code>以后整个函数才会结束</p>
</li>
<li><p>函数内部没有部署<code>try-catch</code>，<code>throw()</code>抛错将被外部<code>try-catch</code>捕获</p>
</li>
<li><p><code>throw()</code>抛错要被内部捕获，前提是必须至少执行过一次<code>next()</code></p>
</li>
<li><p><code>throw()</code>被捕获以后，会附带执行下一条<code>yield</code>命令</p>
</li>
<li><p>函数还未开始执行，这时<code>throw()</code>抛错只可能抛出在函数外部</p>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>异步操作同步化表达</p>
</li>
<li><p>控制流管理</p>
</li>
<li><p>为对象部署<code>Iterator</code>接口：把<code>Generator</code>函数赋值给对象的<code>Symbol.iterator</code>，从而使该对象具有<code>Iterator</code>接口</p>
</li>
<li><p>作为具有<code>Iterator</code>接口的数据结构</p>
</li>
</ol>
</li>
</ol>
<h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2><ol>
<li><p>定义：使异步函数以同步函数的形式书写(<code>Generator</code>函数语法糖)</p>
</li>
<li><p>原理：将<code>Generator</code>函数和自动执行器<code>spawn</code>包装在一个函数里</p>
</li>
<li><p>形式：将<code>Generator</code>函数的<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></p>
</li>
<li><p>声明</p>
<ol>
<li><p>具名函数：<code>async function Func() &#123;&#125;</code></p>
</li>
<li><p>函数表达式：<code>const func = async function() &#123;&#125;</code></p>
</li>
<li><p>箭头函数：<code>const func = async() =&gt; &#123;&#125;</code></p>
</li>
<li><p>对象方法：<code>const obj = &#123; async func() &#123;&#125; &#125;</code></p>
</li>
<li><p>类方法：<code>class Cla &#123; async Func() &#123;&#125; &#125;</code></p>
</li>
</ol>
</li>
<li><p><code>await</code>命令：等待当前<code>Promise</code>对象状态变更完毕</p>
<ol>
<li><p>正常情况：后面是<code>Promise</code>对象则返回其结果，否则返回对应的值</p>
</li>
<li><p>后随<code>Thenable</code>对象：将其等同于<code>Promise</code>对象返回其结果</p>
</li>
</ol>
</li>
<li><p>错误处理：将<code>await</code>命令<code>Promise</code>对象放到<code>try-catch</code>中(可放多个)</p>
</li>
<li><p>异步迭代器(<code>for-await-of</code>)：循环等待每个<code>Promise</code>对象变为<code>resolved</code>状态才进入下一步</p>
</li>
<li><p><code>Async</code>对<code>Generator</code>改进</p>
<ol>
<li><p>内置执行器</p>
</li>
<li><p>更好的语义</p>
</li>
<li><p>更广的适用性</p>
</li>
<li><p>返回值是<code>Promise</code>对象</p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p><code>Async</code>函数返回<code>Promise</code>对象，可使用<code>then()</code>添加回调函数</p>
</li>
<li><p>内部<code>return</code>返回值会成为后续<code>then()</code>的出参</p>
</li>
<li><p>内部抛出错误会导致返回的<code>Promise</code>对象变为<code>rejected</code>状态，被<code>catch()</code>接收到</p>
</li>
<li><p>返回的<code>Promise</code>对象必须等到内部所有<code>await</code>命令<code>Promise</code>对象执行完才会发生状态改变，除非遇到<code>return</code>语句或抛出错误</p>
</li>
<li><p>任何一个<code>await</code>命令<code>Promise</code>对象变为<code>rejected</code>状态，整个<code>Async</code>函数都会中断执行</p>
</li>
<li><p>希望即使前一个异步操作失败也不要中断后面的异步操作</p>
<ol>
<li><p>将<code>await</code>命令<code>Promise</code>对象放到<code>try-catch</code>中</p>
</li>
<li><p><code>await</code>命令<code>Promise</code>对象跟一个<code>catch()</code></p>
</li>
</ol>
</li>
<li><p><code>await</code>命令<code>Promise</code>对象可能变为<code>rejected</code>状态，最好把其放到<code>try-catch</code>中</p>
</li>
<li><p>多个<code>await</code>命令<code>Promise</code>对象若不存在继发关系，最好让它们同时触发</p>
</li>
<li><p><code>await</code>命令只能用在<code>Async</code>函数之中，否则会报错</p>
</li>
<li><p>数组使用<code>forEach()</code>执行<code>async/await</code>会失效，可使用<code>for-of</code>和<code>Promise.all()</code>代替</p>
</li>
<li><p>可保留运行堆栈，函数上下文随着<code>Async</code>函数的执行而存在，执行完成就消失</p>
</li>
</ol>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a href="https://es6.ruanyifeng.com/" title="ES6 入门教程 - ECMAScript 6入门 (ruanyifeng.com)">ES6 入门教程 - ECMAScript 6入门 (ruanyifeng.com)</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903959283367950" title="https://juejin.cn/post/6844903959283367950">https://juejin.cn/post/6844903959283367950</a></p>
</li>
<li><p><a href="https://juejin.cn/post/7133397098719870990" title="你到底懂不懂JavaScript？来做做这12道面试题试试！ - 掘金 (juejin.cn)">你到底懂不懂JavaScript？来做做这12道面试题试试！ - 掘金 (juejin.cn)</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo基本操作指南</title>
    <url>/2021/10/01/Hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://link.zhihu.com/?target=https://hexo.io/zh-cn/" title="Hexo">Hexo</a>是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="https://link.zhihu.com/?target=http://daringfireball.net/projects/markdown/" title="Markdown">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。即把用户的markdown文件，按照指定的主题解析成静态网页</p>
<span id="more"></span>

<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><ul>
<li><p>步骤</p>
<ol>
<li><p><a href="Node.js%E4%B8%8B%E8%BD%BD" title="Node.js">Node.js</a>下载</p>
</li>
<li><p><a href="http://git-scm.com/" title="Git">Git</a>下载</p>
</li>
<li><p>安装<code>Hexo</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化<code>Hexo</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>hexo相关命令均在<code>站点目录</code>下，用<code>Git Bash</code>运行</p>
</li>
<li><p>站点配置文件 <code>_config.yml</code></p>
</li>
<li><p>站点目录下的<code>themes</code>文件夹下的，主题文件夹下的<code>_config.yml</code></p>
</li>
</ol>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure>

<h2 id="文章管理"><a href="#文章管理" class="headerlink" title="文章管理"></a>文章管理</h2><ol>
<li><p>创建一个md文件</p>
<ol>
<li><p>命令创建</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo new &lt;title&gt;</span><br><span class="line">hexo new <span class="string">&quot;我的第一篇文章&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不使用命令自己创建&amp;#x20;</p>
<ul>
<li>只需在文件开头手动加入如下格式 Front-matter</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line">tags: # 标签</span><br><span class="line"><span class="bullet">-</span> PS3</span><br><span class="line"><span class="section">- Games</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>布局（layout）</p>
<ul>
<li><p>创建md文件时，我们可以指定布局</p>
</li>
<li><p>布局有三种</p>
<ol>
<li><p><code>post</code>（文章）</p>
</li>
<li><p><code>draft</code>（草稿）</p>
</li>
<li><p><code>page</code>（页面）</p>
</li>
</ol>
</li>
<li><p>如果没有指定布局类型，则为默认布局<code>post</code>，可以在站点配置文件<code>_config.yml</code>修改 <code>default_layout</code> 参数来修改默认布局</p>
</li>
</ul>
</li>
<li><p>Front-matter</p>
<ul>
<li><p>它是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量</p>
</li>
<li><p>预定义参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>layout</code></td>
<td>布局</td>
<td>true</td>
</tr>
<tr>
<td><code>title</code></td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td><code>date</code></td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr>
<td><code>updated</code></td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr>
<td><code>comments</code></td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td><code>tags</code></td>
<td>标签（不适用于分页）</td>
<td></td>
</tr>
<tr>
<td><code>categories</code></td>
<td>分类（不适用于分页）</td>
<td></td>
</tr>
<tr>
<td><code>permalink</code></td>
<td>覆盖文章网址</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>为文章添加分类与标签</p>
<ul>
<li><p>只有文章（<code>post</code>布局）支持分类和标签，需要在<code>Front-matter</code>中设置。分类有层级关系，标签没有</p>
</li>
<li><p>找到<code>index.md</code>这个文件，添加<code>type: &quot;categories&quot;</code>，<code>type: &quot;tags&quot;</code>到内容中</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017-05-27 13:47:40</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017-05-27 13:47:40</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> [日常, 生活]</span><br><span class="line"><span class="bullet">-</span> [日常, 随想]</span><br><span class="line"><span class="bullet">-</span> [日记]</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> Hexo</span><br><span class="line"><span class="bullet">-</span> 博客</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="部署到GitHub-Pages"><a href="#部署到GitHub-Pages" class="headerlink" title="部署到GitHub Pages"></a>部署到GitHub Pages</h2><ul>
<li><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面</p>
</li>
<li><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布</p>
<p><img src="https://pic3.zhimg.com/80/v2-a193a47cf70fe6ecf156e5f3d34920ea_720w.jpg"></p>
</li>
<li><p>步骤</p>
<ol>
<li><p>连接 Github</p>
<ol>
<li><p>右键 -&gt; <code>Git Bash Here</code>，设置用户名和邮箱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub 用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub 邮箱&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 SSH 密匙：输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车</p>
</li>
<li><p>添加密匙</p>
<ol>
<li><p>进入 [C:\Users\用户名\.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 <code>id_rsa.pub</code> 文件并复制里面的内容</p>
</li>
<li><p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 <code>SSH and GPG keys</code>，点击 <code>New SSH key</code></p>
</li>
<li><p>Title 随便取个名字，粘贴复制的 <code>id_rsa.pub</code> 内容到 Key 中，点击 Add SSH key 完成添加</p>
</li>
</ol>
</li>
<li><p>验证连接</p>
<ol>
<li><p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认</p>
</li>
<li><p>显示 “Hi xxx! You’ve successfully……” 即连接成功</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>创建 Github Pages 仓库</p>
<ol>
<li><p>New repository</p>
</li>
<li><p>Repository name 中输入 <code>用户名.github.io</code></p>
</li>
<li><p>勾选 “Initialize this repository with a README”</p>
</li>
<li><p>Description 选填</p>
</li>
</ol>
</li>
<li><p>部署</p>
<ol>
<li><p>安装 <code>hexo-deployer-git</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>_config.yml</code> 文件末尾的 <code>Deployment </code>部分</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages</p>
</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">// 可以写成一条命令</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="Next主题美化"><a href="#Next主题美化" class="headerlink" title="Next主题美化"></a>Next主题美化</h2><ol>
<li><p>Next主题的安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置站点配置文件_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>选择next主题的布局</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>首页文章展示全文显示摘要：直接在文章中添加 <code>&lt;!-- more --&gt;</code> 来精确控制摘要内容</p>
</li>
<li><p>页面菜单</p>
<ol>
<li>关于<code>about</code>、标签<code>tags</code>和分类<code>categories</code>是需要自行添加页面文件夹，生成about、tags、categories页面</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加站内搜索按钮</p>
<ol>
<li><p>安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator-searchdb</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在站点配置文件中添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加站内搜索按钮</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>皮肤配置文件修改：搜索<code>local_search</code>，<code>enable</code>修改为<code>true</code></p>
</li>
</ol>
</li>
<li><p>设置网站图标”favicon.ico”</p>
<ol>
<li><p>找自己喜欢的ico图标文件，32x32，修改为favicon.ico</p>
</li>
<li><p>把图标文件放在&#x2F;themes&#x2F;next&#x2F;source&#x2F;images里面</p>
</li>
<li><p>修改next配置文件</p>
</li>
</ol>
</li>
<li><p>更改语言</p>
<ul>
<li><p>站点配置文件<code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>添加字数统计及阅读时长</p>
<ol>
<li><p>安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-wordcount</span> <span class="literal">--save</span></span><br><span class="line">npm install hexo<span class="literal">-symbols-count-time</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在站点配置文件添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"> <span class="comment">#文章内是否显示</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line"> <span class="comment"># 网页底部是否显示</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Next主题配置文件修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>  <span class="comment"># 是否换行显示 字数统计 及 阅读时长</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>  <span class="comment"># 文章 字数统计 阅读时长 使用图标 还是 文本表示</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span> <span class="comment"># 博客底部统计 字数统计 阅读时长 使用图标 还是 文本表示</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>代码块增加一键复制</p>
<ul>
<li>该功能next主题已经内置，我们只要打开就行</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add copy button on codeblock</span></span><br><span class="line"><span class="attr">copy_button:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#是否开启复制功能</span></span><br><span class="line">  <span class="comment"># Show text copy result. #是否显示提示的复制结果</span></span><br><span class="line">  <span class="attr">show_result:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加本站运行时间</p>
<ul>
<li>修改&#x2F;blog&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;footer.swig文件，在末尾加入代码</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span> #换行</span><br><span class="line"><span class="comment">&lt;!-- 网站运行时间的设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;timeDate&quot;</span>&gt;</span>载入天数...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;times&quot;</span>&gt;</span>载入时分秒...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">createtime</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> grt= <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;04/21/2019 15:54:40&quot;</span>);<span class="comment">//此处修改你的建站时间或者网站上线时间</span></span></span><br><span class="line"><span class="language-javascript">        now.<span class="title function_">setTime</span>(now.<span class="title function_">getTime</span>()+<span class="number">250</span>);</span></span><br><span class="line"><span class="language-javascript">        days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(days);</span></span><br><span class="line"><span class="language-javascript">        hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(hours);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(<span class="title class_">String</span>(hnum).<span class="property">length</span> ==<span class="number">1</span> )&#123;hnum = <span class="string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum);</span></span><br><span class="line"><span class="language-javascript">        mnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(minutes); <span class="keyword">if</span>(<span class="title class_">String</span>(mnum).<span class="property">length</span> ==<span class="number">1</span> )&#123;mnum = <span class="string">&quot;0&quot;</span> + mnum;&#125;</span></span><br><span class="line"><span class="language-javascript">        seconds = (now - grt ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum);</span></span><br><span class="line"><span class="language-javascript">        snum = <span class="title class_">Math</span>.<span class="title function_">round</span>(seconds); <span class="keyword">if</span>(<span class="title class_">String</span>(snum).<span class="property">length</span> ==<span class="number">1</span> )&#123;snum = <span class="string">&quot;0&quot;</span> + snum;&#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;timeDate&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;本站已安全运行 &quot;</span>+dnum+<span class="string">&quot; 天 &quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;times&quot;</span>).<span class="property">innerHTML</span> = hnum + <span class="string">&quot; 小时 &quot;</span> + mnum + <span class="string">&quot; 分 &quot;</span> + snum + <span class="string">&quot; 秒&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"><span class="built_in">setInterval</span>(<span class="string">&quot;createtime()&quot;</span>,<span class="number">250</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加站点访问人数和总访问量</p>
<ul>
<li>修改next主题配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码块主题</p>
<ul>
<li>修改next主题配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span> <span class="string">bright</span> <span class="comment">#原始normal</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>页面加载条</p>
<ol>
<li><p>安装pace模块到theme&#x2F;next&#x2F;source&#x2F;lib文件夹下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git clone https://github.com/theme<span class="literal">-next</span>/theme<span class="literal">-next-pace</span> source/lib/pace</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改next主题配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#原始false</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">minimal</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>显示当前浏览进度</p>
<ul>
<li><p>打开 <code>themes/next/_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Scroll percent label in b2t button</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>顶部阅读进度条</p>
<ul>
<li><p>阅读进度条动画需要安装依赖</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入主题目录</span></span><br><span class="line"><span class="string">cd</span> <span class="string">themes/next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从GitHub下载依赖文件</span></span><br><span class="line"><span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/theme-next/theme-next-reading-progress</span> <span class="string">source/lib/reading_progress</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主题配置文件<code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">2px</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/85037427" title="Hexo系列 | Hexo的基本使用">Hexo系列 | Hexo的基本使用</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/60578464#:~:text=%E4%BD%BF%E7%94%A8%20Hexo+GitHub%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89%201%20%E5%87%86%E5%A4%87%202%20%E8%BF%9E%E6%8E%A5%20Github....,Hexo%20%E5%88%B0%20GitHub%20Pages%206%20%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89....%207%20%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8" title="使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/69211731" title="Hexo 博客美化合集（不断更新） - 知乎 (zhihu.com)">Hexo 博客美化合集（不断更新） - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://blog.mrzorg.top/Hexo/2020-02-12-hero-next-theme-settings/" title="Hexo的Next主题美化设置 | zorg&#39;s Blog (mrzorg.top)">Hexo的Next主题美化设置 | zorg’s Blog (mrzorg.top)</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/d08513d38786" title="Hexo博客NexT主题美化之顶部加载进度条 - 简书 (jianshu.com)">Hexo博客NexT主题美化之顶部加载进度条 - 简书 (jianshu.com)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_34342905/article/details/88218109" title="Hexo博客NexT主题美化之显示当前浏览进度_weixin_34342905的博客-CSDN博客">Hexo博客NexT主题美化之显示当前浏览进度_weixin_34342905的博客-CSDN博客</a></p>
</li>
<li><p><a href="https://tding.top/archives/dfac1e9c.html" title="Hexo-NexT 主题样式美化 - 动画设置 | 小丁的个人博客 (tding.top)">Hexo-NexT 主题样式美化 - 动画设置 | 小丁的个人博客 (tding.top)</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Iterator&amp;Generator&amp;async</title>
    <url>/2022/05/28/Iterator&amp;Generator&amp;async/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>async</code>、 <code>await</code> 语法是<code>ES7</code>出现的，是基于<code>ES6</code>的<code>Promise</code>和<code>Generator</code>实现的</p>
<span id="more"></span>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><p><a href="#iteratorgeneratorasync">Iterator&amp;Generator&amp;async</a></p>
<ul>
<li><p><a href="#iterator">Iterator</a></p>
<ul>
<li><p><a href="#%E6%A6%82%E5%BF%B5">概念</a></p>
</li>
<li><p><a href="#%E4%BD%9C%E7%94%A8">作用</a></p>
</li>
<li><p><a href="#%E5%8E%9F%E7%94%9F%E5%85%B7%E5%A4%87-iterator-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">原生具备 Iterator 接口的数据结构</a></p>
</li>
<li><p><a href="#%E5%8E%9F%E7%90%86">原理</a></p>
</li>
<li><p><a href="#%E5%BA%94%E7%94%A8">应用</a></p>
</li>
<li><p><a href="#%E7%94%A8%E6%B3%95">用法</a></p>
</li>
</ul>
</li>
<li><p><a href="#generator">Generator</a></p>
<ul>
<li><p><a href="#%E6%A6%82%E5%BF%B5-1">概念</a></p>
</li>
<li><p><a href="#yield%E8%A1%A8%E8%BE%BE%E5%BC%8F">yield表达式</a></p>
</li>
<li><p><a href="#generatorprototypenext">Generator.prototype.next()</a></p>
</li>
<li><p><a href="#generatorprototypethrow">Generator.prototype.throw()</a></p>
</li>
<li><p><a href="#generatorprototypereturn">Generator.prototype.return()</a></p>
</li>
<li><p><a href="#nextthrowreturn-%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9">next()、throw()、return() 的共同点</a></p>
</li>
<li><p><a href="#yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F">yield* 表达式</a></p>
</li>
<li><p><a href="#%E7%94%A8%E6%B3%95-1">用法</a></p>
</li>
</ul>
</li>
<li><p><a href="#async">async</a></p>
<ul>
<li><p><a href="#%E6%A6%82%E5%BF%B5-2">概念</a></p>
</li>
<li><p><a href="#%E4%BC%98%E5%8C%96">优化</a></p>
</li>
<li><p><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a></p>
</li>
<li><p><a href="#await%E5%91%BD%E4%BB%A4">await命令</a></p>
</li>
<li><p><a href="#%E7%94%A8%E6%B3%95-2">用法</a></p>
</li>
</ul>
</li>
<li><p><a href="#%E5%8F%82%E8%80%83">参考</a></p>
</li>
</ul>
</li>
</ul>
<h1 id="Iterator-amp-Generator-amp-async"><a href="#Iterator-amp-Generator-amp-async" class="headerlink" title="Iterator&amp;Generator&amp;async"></a>Iterator&amp;Generator&amp;async</h1><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li><p>是一种接口，为各种不同的数据结构提供统一的访问机制</p>
</li>
<li><p>任何数据结构只要部署 <code>Iterator</code>接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）</p>
</li>
</ol>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li><p>各种数据结构，提供一个统一的、简便的访问接口</p>
</li>
<li><p>使得数据结构的成员能够按某种次序排列</p>
</li>
<li><p>ES6 创造了一种新的遍历命令<code>for...of</code>循环，<code>Iterator</code>接口主要供<code>for...of</code>消费</p>
</li>
</ol>
<h3 id="原生具备-Iterator-接口的数据结构"><a href="#原生具备-Iterator-接口的数据结构" class="headerlink" title="原生具备 Iterator 接口的数据结构"></a>原生具备 Iterator 接口的数据结构</h3><ol>
<li><p><code>Array</code></p>
</li>
<li><p><code>Map</code></p>
</li>
<li><p><code>Set</code></p>
</li>
<li><p><code>String</code></p>
</li>
<li><p><code>TypedArray</code></p>
</li>
<li><p>函数的 <code>arguments</code>对象</p>
</li>
<li><p><code>NodeList</code>对象</p>
</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li><p>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象</p>
</li>
<li><p>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员</p>
</li>
<li><p>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员</p>
</li>
<li><p>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置</p>
</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li><p>解构赋值时，会默认调用<code>Symbol.iterator</code>方法</p>
</li>
<li><p>扩展运算符（<code>...</code>）也会调用默认的 <code>Iterator</code>接口</p>
</li>
<li><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口</p>
</li>
<li><p>对于类似数组的对象（存在数值键名和<code>length</code>属性），部署 <code>Iterator</code>接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的 <code>Iterator</code>接口</p>
</li>
</ol>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">                &#123; <span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span> &#125; :</span><br><span class="line">                &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">makeIterator</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象部署Iterator接口</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(index &lt; keys.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="variable language_">this</span>[keys[index++]],</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="literal">undefined</span>,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似数组的对象（存在数值键名和length属性），部署 Iterator 接口</span></span><br><span class="line"><span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = [][<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line"></span><br><span class="line">[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)] <span class="comment">// 可以执行了</span></span><br></pre></td></tr></table></figure>

<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ol>
<li><p>通过 <code>function *</code>声明，函数体内部使用<code>yield</code>表达式，作为对象属性时，  <code>* myGeneratorMethod</code></p>
</li>
<li><p>执行 <code>Generator</code>函数会返回一个遍历器对象（<code>Iterator Object</code>），实现<code>Iterator</code>接口</p>
</li>
<li><p><code>Generator</code>函数从暂停状态到恢复运行，它的上下文状态（<code>context</code>）是不变的，<code>Generator </code>函数执行产生的上下文环境，一旦遇到<code>yield</code>命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态，等到对它执行<code>next</code>命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行</p>
</li>
<li><p>箭头函数不能定义生成器函数</p>
</li>
</ol>
<h3 id="yield表达式"><a href="#yield表达式" class="headerlink" title="yield表达式"></a>yield表达式</h3><ol>
<li><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code></p>
</li>
<li><p><code>yield</code>表达式就是暂停标志</p>
</li>
<li><p><code>yield</code>表达式后面的表达式，只有当调用<code>next</code>方法、内部指针指向该语句时才会执行</p>
</li>
<li><p><code>yield</code>表达式只能用在 <code>Generator</code>函数里面，用在其他地方都会报错</p>
</li>
<li><p><code>yield</code>表达式如果用在另一个表达式之中，必须放在圆括号里面</p>
</li>
<li><p><code>yield</code>表达式用作函数参数或放在赋值表达式的右边，可以不加括号</p>
</li>
<li><p><code>yield</code>表达式后面接函数的话，到了对应暂停点<code>yield</code>，会马上执行此函数，并且该函数的执行返回值，会被当做此暂停点对象的</p>
</li>
<li><p><code>yield</code>表达式后面接<code>Promise</code>，都是<code>pending</code>状态的<code>Promise</code>对象</p>
</li>
<li><p><code>yield</code>与<code>return</code>异同</p>
<ol>
<li><p>相同点</p>
<ol>
<li><p>都能返回语句后面的那个表达式的值</p>
</li>
<li><p>都可以暂停函数执行</p>
</li>
</ol>
</li>
<li><p>区别</p>
<ol>
<li><p>一个函数可以有多个 <code>yield</code>，但是只能有一个 <code>return</code></p>
</li>
<li><p><code>yield </code>有位置记忆功能，<code>return </code>没有</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Generator-prototype-next"><a href="#Generator-prototype-next" class="headerlink" title="Generator.prototype.next()"></a>Generator.prototype.next()</h3><ol>
<li><p>参数</p>
<ol>
<li><p><code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值</p>
</li>
<li><p>由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的，可以理解为第一个<code>next</code>方法用来启动遍历器对象</p>
</li>
</ol>
</li>
<li><p>运行逻辑</p>
<ol>
<li><p>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值</p>
</li>
<li><p>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式</p>
</li>
<li><p>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值</p>
</li>
<li><p>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></p>
</li>
</ol>
</li>
</ol>
<h3 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h3><ol>
<li><p>Generator 函数返回的迭代器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获</p>
</li>
<li><p><code>throw</code>方法可以接受一个参数，该参数会被<code>catch</code>语句接收，建议抛出<code>Error</code>对象的实例</p>
</li>
<li><p>全局的<code>throw</code>命令只能被函数体外的<code>catch</code>语句捕获</p>
</li>
<li><p>如果 Generator 函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获</p>
</li>
<li><p>如果 Generator 函数内部和外部，都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行</p>
</li>
<li><p><code>throw</code>方法抛出的错误要被内部捕获，前提是必须至少执行过一次<code>next</code>方法</p>
</li>
<li><p><code>throw</code>方法被捕获以后，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次<code>next</code>方法</p>
</li>
<li><p>多个<code>yield</code>表达式，可以只用一个<code>try...catch</code>代码块来捕获错误</p>
</li>
<li><p>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了，即 JavaScript 引擎认为这个 Generator 已经运行结束了</p>
</li>
</ol>
<h3 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h3><ol>
<li><p><code>Generator</code>函数返回的遍历器对象，有一个<code>return()</code>方法，可以提供参数作为返回值，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>，不体东并且终结遍历 <code>Generator</code>函数</p>
</li>
<li><p>如果 <code>Generator</code>函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return()</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束</p>
</li>
</ol>
<h3 id="next-、throw-、return-的共同点"><a href="#next-、throw-、return-的共同点" class="headerlink" title="next()、throw()、return() 的共同点"></a>next()、throw()、return() 的共同点</h3><ol>
<li><p>都是让 <code>Generator</code>函数恢复执行</p>
</li>
<li><p><code>next()</code>是将<code>yield</code>表达式替换成一个值</p>
</li>
<li><p><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句</p>
</li>
<li><p><code>return()</code>是将<code>yield</code>表达式替换成一个<code>return</code>语句</p>
</li>
</ol>
<h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h3><ol>
<li><p>用来在一个 <code>Generator</code>函数里面执行另一个 <code>Generator</code>函数</p>
</li>
<li><p><code>yield*</code>后面的 <code>Generator</code>函数（没有<code>return</code>语句时），等同于在 <code>Generator</code>函数内部，部署一个<code>for...of</code>循环</p>
</li>
<li><p>任何数据结构只要有 <code>Iterator</code>接口，就可以被<code>yield*</code>遍历，<code>yield*</code>后面跟着一个数组会遍历数组成员</p>
</li>
<li><p>被代理的 <code>Generator</code>函数有<code>return</code>语句，那么就可以向代理它的 <code>Generator</code>函数返回数据</p>
</li>
</ol>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">myGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGen = <span class="title function_">myGenerator</span>();</span><br><span class="line"></span><br><span class="line">myGen.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">myGen.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">myGen.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">myGen.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象部署iterator接口</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>*() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> &#123; key, value &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ol>
<li><p><code>await</code>只能在<code>async</code>函数中使用，不然会报错</p>
</li>
<li><p><code>async/await</code>的优势在于处理由多个<code>Promise</code>组成的 <code>then</code>链回调地狱的问题，<code>async/await</code>相当于对<code>Promise</code>的进一步优化</p>
</li>
<li><p><code>async</code>作用是用同步方式，执行异步操作，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数</p>
</li>
<li><p><code>Generator</code>函数的语法糖，将 <code>Generator</code>函数的星号<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></p>
</li>
</ol>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol>
<li><p><code>async</code>函数自带执行器，执行与普通函数一样，不需要调用<code>next</code>方法</p>
</li>
<li><p>语义更清楚，<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果</p>
</li>
<li><p><code>async</code>函数的<code>await</code>命令后面，可以是 <code>Promise</code>对象和原始类型的值，<code>await any</code>可以理解成用 <code>Promise.resolve(any)</code> 处理</p>
</li>
<li><p><code>async</code>函数的返回值是 <code>Promise</code>对象，有无值看有无<code>return</code>值，比操作<code>Iterator</code>对象方便</p>
</li>
</ol>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ol>
<li><p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态，抛出的错误对象会被<code>catch</code>方法回调函数接收到</p>
</li>
<li><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code></p>
</li>
<li><p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中，有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中</p>
</li>
</ol>
<h3 id="await命令"><a href="#await命令" class="headerlink" title="await命令"></a>await命令</h3><ol>
<li><p><code>await</code>命令后面是一个 <code>Promise</code>对象，返回该对象的结果，如果不是 <code>Promise</code>对象，就直接返回对应的值</p>
</li>
<li><p><code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 <code>Promise</code>对象</p>
</li>
<li><p><code>await</code>命令后面的 <code>Promise</code>对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到</p>
</li>
<li><p>任何一个<code>await</code>语句后面的 <code>Promise</code>对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行</p>
</li>
</ol>
<h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generator函数的语法糖，实现原理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generatorToAsync</span>(<span class="params">generatorFn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> gen = generatorFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>) <span class="comment">// gen有可能传参</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个Promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">key, arg</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> res</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里有可能会执行返回reject状态的Promise</span></span><br><span class="line">                    res = gen[key](arg)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="comment">// 报错的话会走catch，直接reject</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_">reject</span>(error)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解构获得value和done</span></span><br><span class="line">                <span class="keyword">const</span> &#123; value, done &#125; = res</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果done为true，说明走完了，进行resolve(value)</span></span><br><span class="line">                <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_">resolve</span>(value)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果done为false，说明没走完，还得继续走</span></span><br><span class="line">                    <span class="comment">// value有可能是：常量，Promise，Promise有可能是成功或者失败</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> <span class="title function_">go</span>(<span class="string">&#x27;next&#x27;</span>, val), <span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">go</span>([<span class="string">&#x27;throw&#x27;</span>, err]))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第一次执行</span></span><br><span class="line">            <span class="title function_">go</span>(<span class="string">&#x27;next&#x27;</span>)   </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async 函数有多种使用形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; &#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>().<span class="title function_">then</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cachePromise</span> = caches.<span class="title function_">open</span>(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getAvatar</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">cachePromise</span>;</span><br><span class="line">    <span class="keyword">return</span> cache.<span class="title function_">match</span>(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> <span class="title class_">Storage</span>();</span><br><span class="line">storage.<span class="title function_">getAvatar</span>(<span class="string">&#x27;jake&#x27;</span>).<span class="title function_">then</span>(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>()</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发，缩短程序的执行时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> barPromise = <span class="title function_">getBar</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一组异步操作，需要按照顺序完成</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.<span class="title function_">map</span>(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">text</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://juejin.cn/post/6844903512845860872#heading-10" title="这一次，彻底弄懂 JavaScript 执行机制 - 掘金 (juejin.cn)">这一次，彻底弄懂 JavaScript 执行机制 - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="http://latentflip.com/loupe" title="http://latentflip.com/loupe">http://latentflip.com/loupe</a></p>
</li>
<li><p><a href="https://juejin.cn/post/7007031572238958629" title="7张图，20分钟就能搞定的async/await原理！为什么要拖那么久？ - 掘金 (juejin.cn)">7张图，20分钟就能搞定的async&#x2F;await原理！为什么要拖那么久？ - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="https://es6.ruanyifeng.com/#docs/generator" title="Generator 函数的语法 - ECMAScript 6入门 (ruanyifeng.com)">Generator 函数的语法 - ECMAScript 6入门 (ruanyifeng.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Iterator</tag>
        <tag>Generator</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2022/04/20/Promise/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而<code>Promise</code>将回调嵌套改为链式调用，增加可读性和可维护性</p>
<span id="more"></span>

<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><ul>
<li><code>Promise</code>是一个对象，从它可以获取异步操作的消息</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li><p>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）</p>
</li>
<li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果</p>
</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p>无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消</p>
</li>
<li><p>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部</p>
</li>
<li><p>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p>
</li>
</ol>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol>
<li><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>，是两个函数，由 JavaScript 引擎提供，不用自己部署</p>
</li>
<li><p><code>then</code>方法可以接受两个回调函数作为参数，第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供</p>
</li>
<li><p>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行</p>
</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li><p>Promise.resolve()</p>
<ol>
<li><p>返回一个新的<code>Promise</code>实例，该实例的状态为<code>resolved</code></p>
</li>
<li><p>将现有对象转为 <code>Promise</code>对象</p>
</li>
<li><p>参数分成四种情况</p>
<ol>
<li><p>参数是一个<code>Promise</code>实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例</p>
</li>
<li><p>参数是一个<code>thenable</code>对象，<code>thenable</code>对象指的是具有<code>then</code>方法的对象</p>
</li>
<li><p>参数不是具有<code>then</code>方法的对象，或根本就不是对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>，参数会传给回调函数</p>
</li>
<li><p>不带有任何参数，直接返回一个<code>resolved</code>状态的 Promise 对象</p>
</li>
</ol>
</li>
<li><p>在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时</p>
</li>
</ol>
</li>
<li><p>Promise.reject()</p>
<ol>
<li><p>返回一个新的<code>Promise</code>实例，该实例的状态为<code>rejected</code></p>
</li>
<li><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数</p>
</li>
</ol>
</li>
<li><p>Promise.try()</p>
<ol>
<li><p>可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误</p>
</li>
<li><p>.catch只能捕获异步错误</p>
</li>
</ol>
</li>
<li><p>Promise.all()</p>
<ol>
<li><p>将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例</p>
</li>
<li><p>接受一个数组作为参数，如果不是，就会先调用<code>Promise.resolve</code>方法，将参数转为<code>Promise</code>实例，参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是<code>Promise</code>实例</p>
</li>
<li><p>接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调</p>
</li>
<li><p>如果作为参数的<code>Promise</code>实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法</p>
</li>
<li><p>返回值为异步函数的返回值组成的数组，数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">http</span>(<span class="params">value, flag</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span>) &#123; <span class="comment">// 设定一个成功或者失败的条件</span></span><br><span class="line">        <span class="title function_">resolve</span>(value)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(flag ? <span class="string">&#x27;重新请求成功&#x27;</span> : <span class="string">&#x27;第一次请求成功&#x27;</span>, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(flag ? <span class="string">&#x27;重新请求失败&#x27;</span> : <span class="string">&#x27;第一次请求失败&#x27;</span>, value)</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="title function_">http</span>(value, <span class="literal">true</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> A = <span class="title function_">http</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> B = <span class="title function_">http</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> C = <span class="title function_">http</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> D = <span class="title function_">http</span>(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([A, B, C, D]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.allSettled()</p>
<ol>
<li><p>接受一组<code>Promise</code>实例作为参数，包装成一个新的<code>Promise</code>实例，只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例都会结束</p>
</li>
<li><p>状态只可能变成<code>fulfilled</code></p>
</li>
<li><p>返回值为由对象组成的数组，对象属性有<code>status</code>和<code>value</code></p>
</li>
<li><p>不关心异步操作的结果，只关心这些操作有没有结束</p>
</li>
</ol>
</li>
<li><p>Promise.race()</p>
<ol>
<li><p>将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例</p>
</li>
<li><p>接受一个数组作为参数，如果不是，就会先调用<code>Promise.resolve</code>方法，将参数转为<code>Promise</code>实例</p>
</li>
<li><p>接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃</p>
</li>
</ol>
</li>
<li><p>Promise.any()</p>
<ol>
<li><p>将多个 <code>Promise</code>实例，包装成一个新的 <code>Promise</code>实例</p>
</li>
<li><p>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态</p>
</li>
</ol>
</li>
<li><p>Promise.prototype.then()</p>
<ol>
<li><p>为 <code>Promise</code>实例添加状态改变时的回调函数</p>
</li>
<li><p><code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数，两个都是可选参数</p>
</li>
<li><p>返回值是一个新的<code>Promise</code>实例</p>
</li>
</ol>
</li>
<li><p>Promise.prototype.catch()</p>
<ol>
<li><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</p>
</li>
<li><p><code>reject()</code>方法的作用，等同于抛出错误</p>
</li>
<li><p>错误总是会被下一个<code>catch</code>语句捕获</p>
</li>
<li><p>如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应</p>
</li>
</ol>
</li>
<li><p>Promise.prototype.finally()</p>
<ol>
<li><p>指定不管 <code>Promise</code>对象最后状态如何，都会执行的操作</p>
</li>
<li><p><code>finally</code>方法的回调函数不接受任何参数</p>
</li>
<li><p>返回的默认会是一个上一次的<code>Promise</code>对象值</p>
</li>
<li><p><code>finally</code>本质上是<code>then</code>方法的特例</p>
</li>
</ol>
</li>
</ol>
<h2 id="值穿透"><a href="#值穿透" class="headerlink" title="值穿透"></a>值穿透</h2><ol>
<li><p>.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透</p>
</li>
<li><p>当then中传入的不是函数，则这个then返回的promise的data，将会保存上一个的promise.data</p>
</li>
<li><p>每一个无效的then所返回的promise的状态都为resolved</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p><code>Promise</code>的状态一经改变就不能再改变</p>
</li>
<li><p><code>.then</code>和<code>.catch</code>都会返回一个新的<code>Promise</code></p>
</li>
<li><p><code>catch</code>不管被连接到哪里，都能捕获上层未捕捉过的错误</p>
</li>
<li><p>在<code>Promise</code>中，返回任意一个非 <code>promise</code> 的值都会被包裹成 <code>promise</code> 对象，例如<code>return 2</code>会被包装为<code>return Promise.resolve(2)</code></p>
</li>
<li><p><code>Promise</code> 的 <code>.then</code> 或者 <code>.catch</code> 可以被调用多次, 但如果<code>Promise</code>内部的状态一经改变，并且有了一个值，那么后续每次调用<code>.then</code>或者<code>.catch</code>的时候都会直接拿到该值</p>
</li>
<li><p><code>.then</code> 或者 <code>.catch</code> 中 <code>return</code> 一个 <code>error</code> 对象并不会抛出错误，所以不会被后续的 <code>.catch</code> 捕获</p>
</li>
<li><p><code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环</p>
</li>
<li><p><code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值透传</p>
</li>
<li><p><code>.then</code>方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为<code>catch</code>是<code>.then</code>第二个参数的简便写法</p>
</li>
<li><p><code>.finally</code>方法也是返回一个<code>Promise</code>，他在<code>Promise</code>结束的时候，无论结果为<code>resolved</code>还是<code>rejected</code>，都会执行里面的回调函数</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://www.jianshu.com/p/fe0159f8beb4" title="Promise和Async/Await用法整理 - 简书 (jianshu.com)">Promise和Async&#x2F;Await用法整理 - 简书 (jianshu.com)</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844904077537574919" title="【建议星星】要就来45道Promise面试题一次爽到底(1.1w字用心整理) - 掘金 (juejin.cn)">【建议星星】要就来45道Promise面试题一次爽到底(1.1w字用心整理) - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="https://www.bookstack.cn/read/es6-3rd/docs-promise.md" title="Promise 对象 - 《阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版》 - 书栈网 · BookStack">Promise 对象 - 《阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版》 - 书栈网 · BookStack</a></p>
</li>
<li><p><a href="https://github.com/KieSun/all-of-frontend/issues/6" title="第五题：Promise all 错误处理 · Issue #6 · KieSun/all-of-frontend (github.com)">第五题：Promise all 错误处理 · Issue #6 · KieSun&#x2F;all-of-frontend (github.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2响应式原理</title>
    <url>/2022/06/24/Vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Vue</code>是一个易上手的框架，许多便捷功能都在其内部做了集成，其中最有区别性的功能就是其潜藏于底层的响应式系统。组件状态都是响应式的<code>JavaScript</code>对象，当更改它们时，视图会随即更新，这让状态管理更加简单直观</p>
<span id="more"></span>

<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li><p><code>data</code>通过<code>Observer</code>转换成了<code>getter/setter</code>的形式，监听数据变化，同时创建 <code>Dep</code>用来搜集使用该 <code>data</code>的 <code>Watcher</code></p>
</li>
<li><p>编译模板时，如果使用到了 <code>data</code>中的数据，会触发<code>getter</code>方法，然后调用 <code>Dep.addSub</code>方法 将 <code>Watcher</code>搜集起来</p>
</li>
<li><p>当data值被修改时，会触发<code>setter</code>函数，然后调用 <code>Dep.notify</code> 通知所有依赖收集得到的的 <code>Watcher</code>调用<code>update</code>方法更新视图</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c23f770a47243d7a1d25e9e8a5a6482~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp"></p>
<h2 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h2><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><ol>
<li><p>概念</p>
<ol>
<li><p><code>Observer</code>：观察者对象，对对象或数组进行响应式处理，管理响应式化<code>Object.defineProperty</code></p>
</li>
<li><p><code>observe</code>：响应式处理的入口</p>
</li>
<li><p><code>defineReactive</code>：拦截对象上每一个<code>key</code>的<code>get</code>与<code>set</code>函数</p>
</li>
</ol>
</li>
<li><p>解析</p>
<ol>
<li><p>观察者类，将对象的各个属性通过<code>defineReactive</code>转换成 <code>getter/setter</code>形式</p>
</li>
<li><p>劫持<code>getter</code>，当读取数据时会<code>dep.depend()</code>进行依赖收集</p>
<ol>
<li><p>将<code>watcher</code>添加到<code>dep.subs</code>，目的是通过<code>notify</code>通知<code>dep</code>中的所有 <code>watcher</code></p>
</li>
<li><p>将<code>dep</code>添加到<code>watcher.newDeps</code>，目的是通过<code>cleanupDeps</code>对比新旧<code>deps</code>，把不在新<code>deps</code>中的旧<code>dep</code>对应<code>watcher</code>删除</p>
</li>
</ol>
</li>
<li><p>劫持<code>setter</code>，当改变数据时会通知之前依赖收集得到的每一个<code>watcher</code>，调用 <code>update</code> 来更新视图</p>
</li>
<li><p>对象和数组有不同的处理方式</p>
<ol>
<li><p>对象，执行<code>walk()</code>方法循环遍历<code>data</code>对象的所有属性，为每个属性设置 <code>getter</code>、<code>setter</code></p>
</li>
<li><p>数组，实现七种<a href="https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95" title="变异方法">变异方法</a>，再将数组的每个成员进行<code>observe</code>处理，使之成响应式数据</p>
<ol>
<li><p><code>push()</code></p>
</li>
<li><p><code>pop()</code></p>
</li>
<li><p><code>shift()</code></p>
</li>
<li><p><code>unshift()</code></p>
</li>
<li><p><code>splice()</code></p>
</li>
<li><p><code>sort()</code></p>
</li>
<li><p><code>reverse()</code></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>源码</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者类，会被附加到每个被观察的对象上，value.__ob__ = this</span></span><br><span class="line"><span class="comment"> * 将对象的各个属性则会被转换成 getter/setter，并收集依赖和通知更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: any;</span><br><span class="line">  <span class="attr">dep</span>: <span class="title class_">Dep</span>;</span><br><span class="line">  <span class="attr">vmCount</span>: number; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">value</span>: any) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="comment">// 实例化一个 dep</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vmCount</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 在 value 对象上设置 __ob__ 属性</span></span><br><span class="line">    <span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// 判断value是函数还是对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * value 为数组</span></span><br><span class="line"><span class="comment">       * hasProto == &#x27;__proto__&#x27; in &#123;&#125;</span></span><br><span class="line"><span class="comment">       * 用于判断对象是否存在 __proto__ 属性，通过 obj.__proto__ 可以访问对象的原型链</span></span><br><span class="line"><span class="comment">       * 但由于 __proto__ 不是标准属性，所以有些浏览器不支持，比如 IE6-10，Opera10.1</span></span><br><span class="line"><span class="comment">       * 为什么要判断，是因为一会儿要通过 __proto__ 操作数据的原型链</span></span><br><span class="line"><span class="comment">       * 覆盖数组默认的七个原型方法，以实现数组响应式</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果是数组的话就修改数组的原型</span></span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        <span class="comment">// 设置 target.__proto__ 的原型对象为 arrayMethods</span></span><br><span class="line">        <span class="title function_">protoAugment</span>(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在目标对象上定义指定 arrayMethods 属性</span></span><br><span class="line">        <span class="title function_">copyAugment</span>(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对数组进行响应式处理</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// value 为对象，为对象的每个属性（包括嵌套对象）设置响应式</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">walk</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 遍历对象上的每个 key，对每个key的值进行响应式处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (<span class="attr">obj</span>: <span class="title class_">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">defineReactive</span>(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 遍历数组，对数组的每一个元素进行响应式处理，处理数组元素为对象的情况</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (<span class="attr">items</span>: <span class="title class_">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="title function_">observe</span>(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应式处理的真正入口</span></span><br><span class="line"><span class="comment"> * 为对象创建观察者实例，如果对象已经被观察过，则返回已有的观察者实例，否则创建新的观察者实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observe</span> (<span class="attr">value</span>: any, <span class="attr">asRootData</span>: ?boolean): <span class="title class_">Observer</span> | <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// 非对象和 VNode 实例不做响应式处理</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(value) || value <span class="keyword">instanceof</span> <span class="title class_">VNode</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">ob</span>: <span class="title class_">Observer</span> | <span class="keyword">void</span></span><br><span class="line">  <span class="comment">// 如果 value 对象上存在 __ob__ 属性，则表示已经做过观察了，直接返回 __ob__ 属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) &#123;</span><br><span class="line">    ob = value.<span class="property">__ob__</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !<span class="title function_">isServerRendering</span>() &amp;&amp;</span><br><span class="line">    (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value) || <span class="title function_">isPlainObject</span>(value)) &amp;&amp;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) &amp;&amp;</span><br><span class="line">    !value.<span class="property">_isVue</span></span><br><span class="line">  ) &#123;</span><br><span class="line">     <span class="comment">// 创建观察者实例</span></span><br><span class="line">    ob = <span class="keyword">new</span> <span class="title class_">Observer</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.<span class="property">vmCount</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截 obj[key] 的读取和设置操作：</span></span><br><span class="line"><span class="comment"> *   1、在第一次读取时收集依赖，比如执行 render 函数生成虚拟 DOM 时会有读取操作</span></span><br><span class="line"><span class="comment"> *   2、在更新时设置新值并通知依赖更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span> (</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Object</span>,</span><br><span class="line">  <span class="attr">key</span>: string,</span><br><span class="line">  <span class="attr">val</span>: any,</span><br><span class="line">  customSetter?: ?<span class="title class_">Function</span>,</span><br><span class="line">  shallow?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// 在闭包中定义一个dep对象，一个 key 对应 一个 dep</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 obj[key] 的属性描述符，发如果是不可配置对象的话直接 return</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的 getter/setter 中会将其执行，保证不会覆盖之前已经定义的getter/setter</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归调用，处理 val 即 obj[key] 的值为对象的情况，保证对象中的所有 key 都被观察，返回 Observer 对象</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val)</span><br><span class="line">  <span class="comment">// 响应式核心</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// get 拦截对 obj[key] 的读取操作</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">      <span class="comment">// 如果原本对象拥有getter方法则执行</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Dep.target 为 Dep 类的一个静态属性，值为 watcher，在实例化 Watcher 时会被设置</span></span><br><span class="line"><span class="comment">       * 实例化 Watcher 时会执行 new Watcher 时传递的回调函数（computed 除外，因为它懒执行）</span></span><br><span class="line"><span class="comment">       * 而回调函数中如果有 vm.key 的读取行为，则会触发这里的 读取 拦截，进行依赖收集</span></span><br><span class="line"><span class="comment">       * 回调函数执行完以后又会将 Dep.target 设置为 null，避免这里重复收集依赖</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="comment">// 依赖收集，在 dep 中添加 watcher，也在 watcher 中添加 dep</span></span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="comment">// childOb 表示对象中嵌套对象的观察者对象，如果存在也对其进行依赖收集</span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">// 依赖收集，将同一个 watcher 观察者实例放进了两个 depend 中，一个是正在本身闭包中的 depend，另一个是子元素的 depend</span></span><br><span class="line">          <span class="comment">// 这就是 this.key.chidlKey 被更新时能触发响应式更新的原因</span></span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="comment">// 如果是 obj[key] 是数组，则触发数组响应式</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="comment">// 为数组项为对象的项添加依赖</span></span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// set 拦截对 obj[key] 的设置操作</span></span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) &#123;</span><br><span class="line">      <span class="comment">// 旧的 obj[key]</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="comment">// 如果新老值一样，则直接 return，不跟新更不触发响应式更新过程</span></span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        <span class="title function_">customSetter</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// setter 不存在说明该属性是一个只读属性，直接 return</span></span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 设置新值</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        <span class="comment">// 如果原本对象拥有setter方法则执行setter</span></span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 新的值需要重新进行observe，保证数据响应式</span></span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal)</span><br><span class="line">      <span class="comment">// 依赖通知更新</span></span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><ol>
<li><p>概念</p>
<ol>
<li><p>收集和管理依赖</p>
</li>
<li><p><code>Observer</code>与 <code>Dep</code> 是一对一的关系， <code>Dep</code>与 <code>Watcher </code>是多对多的关系，<code>Dep</code>则是 <code>Observer</code>和 <code>Watcher</code>之间的纽带</p>
</li>
</ol>
</li>
<li><p>解析</p>
<ol>
<li><p>读取数据会执行<code>dep.depend</code>，且存在 <code>Dep.target</code>时收集依赖，同时<code>dep</code>也会保存到<code>watcher.deps</code>中</p>
</li>
<li><p><code>Dep.target </code>是当前正在执行的 <code>watcher</code></p>
</li>
<li><p>数据变化会执行<code>dep.notify()</code> 方法，这个方法会遍历<code>dep.subs</code>中的订阅者（<code>watcher</code>）向其发送消息， <code>watcher</code>会执行 <code>update</code>方法去更新视图</p>
</li>
</ol>
</li>
<li><p>源码</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个 dep 对应一个 obj.key</span></span><br><span class="line"><span class="comment"> * 在读取响应式数据时，负责收集依赖，每个 dep（或者说 obj.key）依赖的 watcher 有哪些</span></span><br><span class="line"><span class="comment"> * 在响应式数据更新时，负责通知 dep 中那些 watcher 去执行 update 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">target</span>: ?<span class="title class_">Watcher</span>;</span><br><span class="line">  <span class="attr">id</span>: number;</span><br><span class="line">  <span class="attr">subs</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Watcher</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 dep 中添加 watcher</span></span><br><span class="line">  addSub (<span class="attr">sub</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 dep 中删除 watcher</span></span><br><span class="line">  removeSub (<span class="attr">sub</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依赖收集，当存在 Dep.target 的时候添加 watcher</span></span><br><span class="line">  <span class="comment">// Dep.target 是当前正在执行的 watcher</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知 dep 中的所有 watcher，执行 watcher.update() 方法</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.<span class="property">async</span>) &#123;</span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">id</span> - b.<span class="property">id</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历 dep 中存储的 watcher，执行 watcher.update()</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><ol>
<li><p>概念</p>
<ol>
<li>一个观察者对象，也是依赖，<code>Watcher</code>能够控制自己属于哪个，<code>Watcher</code>自己有统一的更新入口，只要你通知它，就会执行对应的更新方法</li>
</ol>
</li>
<li><p>分类</p>
<ol>
<li><p>渲染<code>watcher</code></p>
</li>
<li><p>computed<code>watcher</code></p>
</li>
<li><p>watch<code>watcher</code></p>
</li>
</ol>
</li>
<li><p>解析</p>
<ol>
<li><p>访问<code>data</code>属性并且<code>Dep.target</code>为<code>true</code>的时候，会进行依赖收集</p>
</li>
<li><p><code>watcher</code>会被保存在<code>dep.subs</code>中，在数据变动时通知<code>watcher</code>，调用<code>watcher.update</code>方法，最后实际上是调用<code>watcher</code>的回调函数<code>cb</code>，进而更新视图</p>
</li>
<li><p><code>dep</code>也会保存到<code>watcher.deps</code>中，为了知道是哪个数据变化，对比新旧<code>deps</code>，把不在新<code>deps</code>中的旧<code>dep</code>对应<code>watcher</code>删除</p>
</li>
</ol>
</li>
<li><p>源码</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个组件一个 watcher（渲染 watcher）或者一个表达式一个 watcher（用户 watcher）</span></span><br><span class="line"><span class="comment"> * 当数据更新时 watcher 会被触发，访问 this.computedProperty 时也会触发 watcher</span></span><br><span class="line"><span class="comment"> * 依赖收集以后 Watcher对象会被保存在 Dep 的 subs 中，数据变动的时候 Dep 会通知 Watcher 实例，然后由 Watcher 实例回调 cb 进行视图的更新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>;</span><br><span class="line">  <span class="attr">expression</span>: string;</span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">Function</span>;</span><br><span class="line">  <span class="attr">id</span>: number;</span><br><span class="line">  <span class="attr">deep</span>: boolean;</span><br><span class="line">  <span class="attr">user</span>: boolean;</span><br><span class="line">  <span class="attr">lazy</span>: boolean;</span><br><span class="line">  <span class="attr">sync</span>: boolean;</span><br><span class="line">  <span class="attr">dirty</span>: boolean;</span><br><span class="line">  <span class="attr">active</span>: boolean;</span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;;</span><br><span class="line">  <span class="attr">newDeps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;;</span><br><span class="line">  <span class="attr">depIds</span>: <span class="title class_">SimpleSet</span>;</span><br><span class="line">  <span class="attr">newDepIds</span>: <span class="title class_">SimpleSet</span>;</span><br><span class="line">  <span class="attr">before</span>: ?<span class="title class_">Function</span>;</span><br><span class="line">  <span class="attr">getter</span>: <span class="title class_">Function</span>;</span><br><span class="line">  <span class="attr">value</span>: any;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (</span><br><span class="line">    <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">    <span class="attr">expOrFn</span>: string | <span class="title class_">Function</span>,</span><br><span class="line">    <span class="attr">cb</span>: <span class="title class_">Function</span>,</span><br><span class="line">    options?: ?<span class="title class_">Object</span>,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm.<span class="property">_watcher</span> = <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// _watchers 存放订阅者实例</span></span><br><span class="line">    vm.<span class="property">_watchers</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span> = !!options.<span class="property">deep</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">user</span> = !!options.<span class="property">user</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lazy</span> = !!options.<span class="property">lazy</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">sync</span> = !!options.<span class="property">sync</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">before</span> = options.<span class="property">before</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span> = <span class="variable language_">this</span>.<span class="property">user</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> = <span class="variable language_">this</span>.<span class="property">sync</span> = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expression</span> = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">      ? expOrFn.<span class="title function_">toString</span>()</span><br><span class="line">      : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// 渲染 watcher 中，这里传入的 expOrFn 是 updateComponent = vm.update(vm.render())</span></span><br><span class="line">    <span class="comment">// this.getter 等价于 vm.update(vm.render())</span></span><br><span class="line">    <span class="comment">// 把表达式 expOrFn 解析成 getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">getter</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getter</span> = noop</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">          <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里进行判断，lazy 为 true 时(计算属性)则什么都不执行，否则执行 get</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span></span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行 this.getter（compute中的函数），并重新收集依赖</span></span><br><span class="line"><span class="comment">   * this.getter 是实例化 watcher 时传递的第二个参数，一个函数或者字符串，比如：updateComponent 或者 parsePath 返回的读取 this.xx 属性值的函数</span></span><br><span class="line"><span class="comment">   * 为什么要重新收集依赖？</span></span><br><span class="line"><span class="comment">   *   因为触发更新说明有响应式数据被更新了，但是被更新的数据虽然已经经过 observe 观察了，但是却没有进行依赖收集</span></span><br><span class="line"><span class="comment">   *   所以，在更新页面时，会重新执行一次 render 函数，执行期间会触发读取操作，这时候进行依赖收集</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="comment">// 将自身 watcher 观察者实例设置给 Dep.target ，用以依赖收集</span></span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// value 为回调函数执行的结果</span></span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 执行回调函数（compute中的函数），比如 updateComponent，进入 patch 阶段</span></span><br><span class="line">      <span class="comment">// 1. 这里调用 getter ，也就是执行 vm.update(vm.render())</span></span><br><span class="line">      <span class="comment">// 2. 执行 vm.render 函数就会访问到响应式数据，触发 get 进行依赖收集</span></span><br><span class="line">      <span class="comment">// 3. 此时的 Dep.target 为当前的渲染 Watcher，数据就可以理所应当的把 Watcher 加入 Dep 实例的 subs 中</span></span><br><span class="line">      <span class="comment">// 4. 所以此时，Watcher 就能监测到数据变化，实现响应式</span></span><br><span class="line">      value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="comment">// 如果存在 deep ，则触发每个深层对象的依赖，追踪其变化</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归每一个对象或者数组，触发它们的 getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系</span></span><br><span class="line">        <span class="title function_">traverse</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将观察者实例从 target 栈中取出并设置给 Dep.target</span></span><br><span class="line">      <span class="title function_">popTarget</span>()</span><br><span class="line">      <span class="comment">// cleanupDeps 是个优化操作，会移除 Watcher 对本次 render 没被使用的数据的观测</span></span><br><span class="line">      <span class="comment">// 对比新旧 deps ，把不在新 deps 中的旧 dep 对应 watcher 删除</span></span><br><span class="line">      <span class="comment">// 效果：处于 v-if 为 false 中的响应式数据改变不会触发 Watcher 的 update</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *   1. 添加 dep 给自己（watcher）</span></span><br><span class="line"><span class="comment">   *   2. 添加自己（watcher）到 dep</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  addDep (<span class="attr">dep</span>: <span class="title class_">Dep</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.<span class="property">id</span></span><br><span class="line">    <span class="comment">// 判重，如果 dep 已经存在则不重复添加</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      <span class="comment">// 缓存 dep.id，用于判重</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id)</span><br><span class="line">      <span class="comment">// 添加 dep</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">      <span class="comment">// 避免在 dep 中重复添加 watcher，this.depIds 的设置在 cleanupDeps 方法中</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">        <span class="comment">// 添加 watcher 自己到 dep</span></span><br><span class="line">        dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清理依赖收集</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="variable language_">this</span>.<span class="property">deps</span>[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(dep.<span class="property">id</span>)) &#123;</span><br><span class="line">        dep.<span class="title function_">removeSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="variable language_">this</span>.<span class="property">depIds</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="variable language_">this</span>.<span class="property">newDepIds</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = tmp</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">clear</span>()</span><br><span class="line">    tmp = <span class="variable language_">this</span>.<span class="property">deps</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = <span class="variable language_">this</span>.<span class="property">newDeps</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = tmp</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 调度者接口，当依赖发生改变的时候进行回调</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">      <span class="comment">// 懒执行时走这里，比如 computed</span></span><br><span class="line">      <span class="comment">// 将 dirty 置为 true，可以让 computedGetter 执行时重新计算 computed 回调函数的执行结果</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">      <span class="comment">// 同步执行，在使用 vm.$watch 或者 watch 选项时可以传一个 sync 选项，</span></span><br><span class="line">      <span class="comment">// 当为 true 时在数据更新时该 watcher 就不走异步更新队列，直接执行 this.run 方法进行更新</span></span><br><span class="line">      <span class="comment">// 这个属性在官方文档中没有出现</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">run</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新时一般都这里，将 watcher 放入 watcher 队列</span></span><br><span class="line">      <span class="comment">// 异步推送到观察者队列中，下一个 tick 时调用</span></span><br><span class="line">      <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 调度者工作接口，将被调度者回调</span></span><br><span class="line"><span class="comment">   * 由 刷新队列函数 flushSchedulerQueue 调用，完成如下几件事：</span></span><br><span class="line"><span class="comment">   *   1. 执行实例化 watcher 传递的第二个参数，updateComponent 或者 获取 this.xx 的一个函数(parsePath 返回的函数)</span></span><br><span class="line"><span class="comment">   *   2. 更新旧值为新值</span></span><br><span class="line"><span class="comment">   *   3. 执行实例化 watcher 时传递的第三个参数，比如用户 watcher 的回调函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">      <span class="comment">// get 操作在获取 value 本身也会执行 getter 从而调用 update 更新视图</span></span><br><span class="line">      <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="variable language_">this</span>.<span class="property">value</span> ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        <span class="comment">// 即便值相同，拥有 Deep 属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变</span></span><br><span class="line">        <span class="title function_">isObject</span>(value) ||</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">deep</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 更新旧值为新值</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">        <span class="comment">// 触发回调</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果是用户 watcher，则执行用户传递的第三个参数 —— 回调函数，参数为 val 和 oldVal</span></span><br><span class="line">          <span class="keyword">const</span> info = <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span></span><br><span class="line">          <span class="title function_">invokeWithErrorHandling</span>(<span class="variable language_">this</span>.<span class="property">cb</span>, <span class="variable language_">this</span>.<span class="property">vm</span>, [value, oldValue], <span class="variable language_">this</span>.<span class="property">vm</span>, info)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 渲染 watcher，this.cb = noop，一个空函数</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取观察者的值</span></span><br><span class="line"><span class="comment">   * 懒执行的 watcher 会调用该方法，比如：computed，在获取 vm.computedProperty 的值时会调用该方法</span></span><br><span class="line"><span class="comment">   * 然后执行 this.get，即 watcher 的回调函数，得到返回值</span></span><br><span class="line"><span class="comment">   * this.dirty 被置为 false，作用是页面在本次渲染中只会一次 computed.key 的回调函数</span></span><br><span class="line"><span class="comment">   * 这也是大家常说的 computed 和 methods 区别之一是 computed 有缓存的原理所在</span></span><br><span class="line"><span class="comment">   * 而页面更新后会 this.dirty 会被重新置为 true，这一步是在 this.update 方法中完成的</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Depend on all deps collected by this watcher.</span></span><br><span class="line"><span class="comment">   * 收集该watcher的所有deps依赖</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deps</span>[i].<span class="title function_">depend</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove self from all dependencies&#x27; subscriber list.</span></span><br><span class="line"><span class="comment">   * 将自身从所有依赖收集订阅列表删除</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  teardown () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">      <span class="comment">// remove self from vm&#x27;s watcher list</span></span><br><span class="line">      <span class="comment">// this is a somewhat expensive operation so we skip it</span></span><br><span class="line">      <span class="comment">// if the vm is being destroyed.</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">_isBeingDestroyed</span>) &#123;</span><br><span class="line">        <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">_watchers</span>, <span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">deps</span>[i].<span class="title function_">removeSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a href="https://juejin.cn/post/6844903597986037768" title="当面试官问你Vue响应式原理，你可以这么回答他 - 掘金 (juejin.cn)">当面试官问你Vue响应式原理，你可以这么回答他 - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="https://jungahuang.com/2018/02/07/about-responsive-of-vue/#more" title="深入理解Vue响应式原理 | Junga&#39;s Blog (jungahuang.com)">深入理解Vue响应式原理 | Junga’s Blog (jungahuang.com)</a></p>
</li>
<li><p><a href="https://juejin.cn/post/7074422512318152718#heading-5" title="纯干货！图解Vue响应式原理 - 掘金 (juejin.cn)">纯干货！图解Vue响应式原理 - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6857669921166491662" title="图解 Vue 响应式原理 - 掘金 (juejin.cn)">图解 Vue 响应式原理 - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6950826293923414047" title="Vue 源码解读（3）—— 响应式原理 - 掘金 (juejin.cn)">Vue 源码解读（3）—— 响应式原理 - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6995079895470571551#heading-5" title="vue源码分析之watcher为何收集dep？ - 掘金 (juejin.cn)">vue源码分析之watcher为何收集dep？ - 掘金 (juejin.cn)</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue2</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>diff算法原理</title>
    <url>/2022/07/20/diff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所谓<code>diff</code>算法，就是通过比对新旧两个虚拟节点不一样的地方，针对那些不一样的地方进行新增或更新或删除操作</p>
<span id="more"></span>


<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><ol>
<li><p>一个用来表示真实DOM的对象</p>
</li>
<li><p>虚拟DOM通过算法操作真实DOM，性能高于直接操作真实DOM</p>
</li>
<li><p>虚拟DOM算法 &#x3D; 虚拟DOM +diff算法</p>
</li>
</ol>
<h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><ol>
<li><p>是一种通过同层的树节点进行比较的高效算法，遵循深度优先、同层比较的策略</p>
</li>
<li><p>对比两者是<code>旧虚拟DOM</code>和<code>新虚拟DOM</code>，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新<code>真实DOM</code>，进而提高效率</p>
</li>
<li><p>组件内响应式数据变更触发实例执行其更新函数时，更新函数会再次执行<code>render</code>函数获得最新的虚拟<code>DOM</code>，然后执行<code>patch</code>函数，并传入新旧两次虚拟<code>DOM</code>，通过比对两者找到变化的地方，最后将其转化为对应的<code>DOM</code>操作</p>
</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><ol>
<li><p>对比当前同层的虚拟节点是否为同一种类型的标签</p>
</li>
<li><p>是：继续执行<code>patchVnode方法</code>进行深层比对</p>
</li>
<li><p>否：没必要比对了，直接整个节点替换成<code>新虚拟节点</code></p>
</li>
</ol>
<h3 id="sameVnode"><a href="#sameVnode" class="headerlink" title="sameVnode"></a>sameVnode</h3><ol>
<li><p>判断是否为同一类型节点</p>
</li>
<li><p>源码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span>(<span class="params">oldVnode, newVnode</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    oldVnode.<span class="property">key</span> === newVnode.<span class="property">key</span> &amp;&amp; <span class="comment">// key值是否一样</span></span><br><span class="line">    oldVnode.<span class="property">tagName</span> === newVnode.<span class="property">tagName</span> &amp;&amp; <span class="comment">// 标签名是否一样</span></span><br><span class="line">    oldVnode.<span class="property">isComment</span> === newVnode.<span class="property">isComment</span> &amp;&amp; <span class="comment">// 是否都为注释节点</span></span><br><span class="line">    <span class="title function_">isDef</span>(oldVnode.<span class="property">data</span>) === <span class="title function_">isDef</span>(newVnode.<span class="property">data</span>) &amp;&amp; <span class="comment">// 是否都定义了data</span></span><br><span class="line">    <span class="title function_">sameInputType</span>(oldVnode, newVnode) <span class="comment">// 当标签为input时，type必须是否相同</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><ol>
<li><p>逻辑</p>
<ol>
<li><p>找到对应的真实<code>DOM</code>，称为<code>el</code></p>
</li>
<li><p>判断<code>newVnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是，那么直接<code>return</code></p>
</li>
<li><p>如果他们都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>newVnode</code>的文本节点</p>
</li>
<li><p>如果<code>oldVnode</code>有子节点而<code>newVnode</code>没有，则删除el的子节点</p>
</li>
<li><p>如果<code>oldVnode</code>没有子节点而<code>newVnode</code>有，则将<code>newVnode</code>的子节点真实化之后添加到el</p>
</li>
<li><p>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，这一步很重要</p>
</li>
</ol>
</li>
<li><p>源码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span>(<span class="params">oldVnode, newVnode</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> el = newVnode.<span class="property">el</span> = oldVnode.<span class="property">el</span> <span class="comment">// 获取真实DOM对象</span></span><br><span class="line">  <span class="comment">// 获取新旧虚拟节点的子节点数组</span></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.<span class="property">children</span>, newCh = newVnode.<span class="property">children</span></span><br><span class="line">  <span class="comment">// 如果新旧虚拟节点是同一个对象，则终止</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode === newVnode) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 如果新旧虚拟节点是文本节点，且文本不一样</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode.<span class="property">text</span> !== <span class="literal">null</span> &amp;&amp; newVnode.<span class="property">text</span> !== <span class="literal">null</span> &amp;&amp; oldVnode.<span class="property">text</span> !== newVnode.<span class="property">text</span>) &#123;</span><br><span class="line">    <span class="comment">// 则直接将真实DOM中文本更新为新虚拟节点的文本</span></span><br><span class="line">    api.<span class="title function_">setTextContent</span>(el, newVnode.<span class="property">text</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldCh &amp;&amp; newCh &amp;&amp; oldCh !== newCh) &#123;</span><br><span class="line">      <span class="comment">// 新旧虚拟节点都有子节点，且子节点不一样</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对比子节点，并更新</span></span><br><span class="line">      <span class="title function_">updateChildren</span>(el, oldCh, newCh)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newCh) &#123;</span><br><span class="line">      <span class="comment">// 新虚拟节点有子节点，旧虚拟节点没有</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建新虚拟节点的子节点，并更新到真实DOM上去</span></span><br><span class="line">      <span class="title function_">createEle</span>(newVnode)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldCh) &#123;</span><br><span class="line">      <span class="comment">// 旧虚拟节点有子节点，新虚拟节点没有</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//直接删除真实DOM里对应的子节点</span></span><br><span class="line">      api.<span class="title function_">removeChild</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><ol>
<li><p>新旧虚拟节点的子节点对比，首尾指针法</p>
</li>
<li><p>判断逻辑</p>
<ol>
<li><p>新老 <code>VNode</code>节点的<code>start</code> 和<code>end</code>有相同时</p>
<ol>
<li><p>当新老 <code>VNode</code>节点的 <code>start</code> 相同时，直接 <code>patchVnode</code> ，同时新老 <code>VNode</code>节点的开始索引都加 1</p>
</li>
<li><p>当新老 <code>VNode</code>节点的 <code>end</code>相同时，同样直接 <code>patchVnode</code> ，同时新老 <code>VNode</code>节点的结束索引都减 1</p>
</li>
<li><p>当老 <code>VNode</code>节点的 <code>start</code> 和新 <code>VNode</code>节点的 <code>end</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldEndVnode</code> 的后面，同时老 <code>VNode</code>节点开始索引加 1，新 <code>VNode</code>节点的结束索引减 1</p>
</li>
<li><p>当老 <code>VNode</code>节点的 <code>end</code> 和新 <code>VNode</code>节点的 <code>start</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldStartVnode</code> 的前面，同时老 <code>VNode</code>节点结束索引减 1，新 <code>VNode</code>节点的开始索引加 1</p>
</li>
</ol>
</li>
<li><p>新老 <code>VNode</code>节点的<code>start</code> 和<code>end</code>都不同时</p>
<ol>
<li><p>从旧的 <code>VNode</code>为 <code>key</code> 值，对应 <code>index</code> 序列为 <code>value</code> 值的哈希表中找到与 <code>newStartVnode</code> 一致 <code>key</code> 的旧的 <code>VNode</code>节点，再进行<code>patchVnode</code>，同时将这个真实 <code>dom</code>移动到 <code>oldStartVnode</code> 对应的真实 <code>dom</code> 的前面</p>
</li>
<li><p>调用 <code>createElm</code> 创建一个新的 <code>dom</code> 节点放到当前 <code>newStartIdx</code> 的位置</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>源码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span> <span class="comment">// 旧头索引</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span> <span class="comment">// 新头索引</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.<span class="property">length</span> - <span class="number">1</span> <span class="comment">// 旧尾索引</span></span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.<span class="property">length</span> - <span class="number">1</span> <span class="comment">// 新尾索引</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>] <span class="comment">// oldVnode的第一个child</span></span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="comment">// oldVnode的最后一个child</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>] <span class="comment">// newVnode的第一个child</span></span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="comment">// newVnode的最后一个child</span></span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">    <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">    <span class="comment">// during leaving transitions</span></span><br><span class="line">    <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束</span></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="comment">// 如果oldVnode的第一个child不存在</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) &#123;</span><br><span class="line">        <span class="comment">// oldStart索引右移</span></span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果oldVnode的最后一个child不存在</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) &#123;</span><br><span class="line">        <span class="comment">// oldEnd索引左移</span></span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldStartVnode和newStartVnode是同一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        <span class="comment">// patch oldStartVnode和newStartVnode， 索引左移，继续循环</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldEndVnode和newEndVnode是同一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        <span class="comment">// patch oldEndVnode和newEndVnode，索引右移，继续循环</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldStartVnode和newEndVnode是同一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">        <span class="comment">// patch oldStartVnode和newEndVnode</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">// 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后</span></span><br><span class="line">        canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="property">elm</span>, nodeOps.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>))</span><br><span class="line">        <span class="comment">// oldStart索引右移，newEnd索引左移</span></span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果oldEndVnode和newStartVnode是同一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">        <span class="comment">// patch oldEndVnode和newStartVnode</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">// 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前</span></span><br><span class="line">        canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">        <span class="comment">// oldEnd索引左移，newStart索引右移</span></span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果都不匹配</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldKeyToIdx)) oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode</span></span><br><span class="line">        idxInOld = <span class="title function_">isDef</span>(newStartVnode.<span class="property">key</span>)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">          : <span class="title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未找到，说明newStartVnode是一个新的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isUndef</span>(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">          <span class="comment">// 创建一个新Vnode</span></span><br><span class="line">          <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !vnodeToMove) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">              <span class="string">&#x27;It seems there are duplicate keys that is causing an update error. &#x27;</span> +</span><br><span class="line">              <span class="string">&#x27;Make sure each v-for item has a unique key.&#x27;</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 比较两个具有相同的key的新节点是否是同一个节点</span></span><br><span class="line">          <span class="comment">//不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            <span class="comment">// patch vnodeToMove和newStartVnode</span></span><br><span class="line">            <span class="title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">            <span class="comment">// 清除</span></span><br><span class="line">            oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">            <span class="comment">// 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm</span></span><br><span class="line">            <span class="comment">// 移动到oldStartVnode.elm之前</span></span><br><span class="line">            canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果key相同，但是节点不相同，则创建一个新的节点</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">            <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右移</span></span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="key的理解"><a href="#key的理解" class="headerlink" title="key的理解"></a>key的理解</h2><ol>
<li><p>为了更高效的更新虚拟<code>DOM</code></p>
</li>
<li><p>在<code>patch</code>过程中判断两个节点是否是相同节点是<code>key</code>是一个必要条件</p>
</li>
<li><p>如果不定义<code>key</code>的话，会认为比较的两个节点是同一个，实际上可能不是，导致了频繁更新元素，使得整个<code>patch</code>过程比较低效，影响性能</p>
</li>
<li><p>遍历列表时避免使用<code>index</code>索引作为<code>key</code>，如果使用<code>index</code>，中间如果插入了一个新元素，则新增元素后面的元素的下标都变化了，要重新计算新增元素以及新增元素后面的值，则重新渲染的虚拟<code>DOM</code>数量增加</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a href="https://blog.csdn.net/m0_45219210/article/details/119389723" title="(21条消息) 为什么遍历列表时，key最好不要用index?_初级的CV工程师的博客-CSDN博客">(21条消息) 为什么遍历列表时，key最好不要用index?_初级的CV工程师的博客-CSDN博客</a></p>
</li>
<li><p><a href="https://juejin.cn/post/7097067108663558151" title="历时一个月，2.6W字！50+Vue经典面试题源码级详解，你值得收藏！ - 掘金 (juejin.cn)">历时一个月，2.6W字！50+Vue经典面试题源码级详解，你值得收藏！ - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="https://vue3js.cn/interview/vue/key.html#%E4%BA%8C%E3%80%81%E8%AE%BE%E7%BD%AEkey%E4%B8%8E%E4%B8%8D%E8%AE%BE%E7%BD%AEkey%E5%8C%BA%E5%88%AB" title="面试官：你知道vue中key的原理吗？说说你对它的理解 | web前端面试 - 面试官系列 (vue3js.cn)">面试官：你知道vue中key的原理吗？说说你对它的理解 | web前端面试 - 面试官系列 (vue3js.cn)</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>原理</tag>
        <tag>diff算法</tag>
      </tags>
  </entry>
  <entry>
    <title>this&amp;new&amp;apply&amp;call&amp;bind</title>
    <url>/2022/02/04/this&amp;new&amp;apply&amp;call&amp;bind/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>this</code>关键字是js中最复杂的机制之一，是一个特别的关键字，被自动定义在所有函数的作用域中，指向问题也比较复杂</p>
<span id="more"></span>

<h2 id="this概念"><a href="#this概念" class="headerlink" title="this概念"></a><code>this</code>概念</h2><ol>
<li><p><code>this</code>就是当前属性或方法所在的对象</p>
</li>
<li><p><code>this</code>对象会在运行时绑定到执行函数的上下文中，为函数的上下文的一个属性</p>
</li>
<li><p><code>this</code>在任何情况下都不指向函数的词法作用域</p>
</li>
<li><p><code>this</code> 永远指向最后调用它的那个对象</p>
</li>
</ol>
<h2 id="this实质"><a href="#this实质" class="headerlink" title="this实质"></a><code>this</code>实质</h2><ol>
<li><p>由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（<code>context</code>）</p>
</li>
<li><p>它的设计目的就是在函数体内部，指代函数当前的运行环境</p>
</li>
</ol>
<h2 id="函数调用方法"><a href="#函数调用方法" class="headerlink" title="函数调用方法"></a>函数调用方法</h2><ol>
<li><p>作为一个函数调用</p>
</li>
<li><p>函数作为方法调用</p>
</li>
<li><p>使用构造函数调用函数</p>
</li>
<li><p>作为函数方法调用函数（<code>call</code>、apply）</p>
</li>
</ol>
<h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><ol>
<li><p>默认绑定</p>
<ol>
<li><p>独立函数调用</p>
</li>
<li><p>非严格模式默认是指向全局对象 <code>window</code>&amp;#x20;</p>
</li>
<li><p>严格模式，就是 <code>undefined</code></p>
</li>
</ol>
</li>
<li><p>隐式绑定</p>
<ol>
<li><p>如果函数调用时，前面存在调用它的对象，那么<code>this</code>就会隐式绑定到这个对象上</p>
</li>
<li><p>如果函数调用前存在多个对象，<code>this</code>指向距离调用自己最近的对象</p>
</li>
<li><p>函数间接引用，隐式丢失会应用默认绑定</p>
</li>
</ol>
</li>
<li><p>显式绑定</p>
<ol>
<li><p>直接指定<code>this</code>绑定对象</p>
</li>
<li><p>硬绑定，解决绑定丢失问题，·<code>bind</code>方法创建一个新的函数, 当被调用时，将其<code>this</code>关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列</p>
</li>
<li><p>软绑定，给默认绑定指定一个全局对象和<code>undefined</code>以外的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span>) &#123;</span><br><span class="line">    <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕获所有curried参数</span></span><br><span class="line">        <span class="keyword">let</span> curried = [].<span class="title function_">slice</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">let</span> bound = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>((!<span class="variable language_">this</span> || <span class="variable language_">this</span> === (<span class="variable language_">window</span> || <span class="variable language_">global</span>)) ? obj : <span class="variable language_">this</span>, curried.<span class="property">concat</span>.<span class="title function_">apply</span>(curried, <span class="variable language_">arguments</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        bound.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">        <span class="keyword">return</span> bound</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><code>new</code>绑定</p>
<ol>
<li>绑定<code>this</code>到新对象上</li>
</ol>
</li>
</ol>
<h2 id="判断this"><a href="#判断this" class="headerlink" title="判断this"></a>判断this</h2><ul>
<li><p>规则内</p>
<ol>
<li><p>函数是否在<code>new</code>中调用（<code>new</code>绑定）</p>
</li>
<li><p>函数是否通过<code>call</code>、<code>apply</code>（显式绑定）或者<code>bind</code>（硬绑定）</p>
</li>
<li><p>函数是否在某个上下文对象中调用（隐式绑定）</p>
</li>
<li><p>如果都不是，使用默认绑定，严格模式为<code>undefined</code></p>
</li>
</ol>
</li>
<li><p>规则外</p>
<ol>
<li><p>箭头函数根据外层作用域来决定<code>this</code>，始终指向函数定义时的 <code>this</code>，而非执行时</p>
</li>
<li><p><code>null</code>，<code>undefined</code>作为this绑定对象传入<code>apply</code>、<code>call</code>、<code>bind</code>，调用时会被忽略，应用默认绑定</p>
</li>
<li><p>忽略this绑定传入DMZ对象，<code>Object.create(null)</code></p>
</li>
<li><p>当函数被用作事件处理函数时，它的 <code>this</code> 指向触发事件的元素</p>
</li>
</ol>
</li>
</ul>
<h2 id="new命令"><a href="#new命令" class="headerlink" title="new命令"></a>new命令</h2><ol>
<li><p>创建一个给定构造函数的实例对象</p>
</li>
<li><p>会劫持所有普通函数并用构造对象的形式来调用&amp;#x20;</p>
</li>
<li><p>如果构造函数内部有<code>return</code>语句，而且<code>return</code>后面跟着一个对象，<code>new</code>命令会返回<code>return</code>语句指定的对象；否则，就会不管<code>return</code>语句，返回<code>this</code>对象</p>
</li>
<li><p>函数内部可以使用<code>new.target</code>属性。如果当前函数是<code>new</code>命令调用，<code>new.target</code>指向当前函数，否则为<code>undefined</code></p>
</li>
<li><p>原理</p>
<ol>
<li><p>创建一个空对象，作为将要返回的对象实例</p>
</li>
<li><p>将这个空对象的原型，指向构造函数的<code>prototype</code>属性</p>
</li>
<li><p>将这个空对象赋值给函数内部的<code>this</code>关键字</p>
</li>
<li><p>开始执行构造函数内部的代码</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    <span class="keyword">let</span> res = fn.<span class="title function_">call</span>(obj, ...args);</span><br><span class="line">    <span class="keyword">if</span> (res &amp;&amp; (<span class="keyword">typeof</span> res === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> res === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="绑定-this的方法"><a href="#绑定-this的方法" class="headerlink" title="绑定 this的方法"></a>绑定 <code>this</code>的方法</h2><ul>
<li><p><code>Function.prototype.call()</code></p>
<ol>
<li><p><code>call</code>方法格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func.<span class="title function_">call</span>(thisValue, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定函数内部<code>this</code>的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函</p>
</li>
<li><p><code>call</code>方法的第一个参数，应该是一个对象。如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象</p>
</li>
<li><p>如果<code>call</code>方法的第一个参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入<code>call</code>方法</p>
</li>
<li><p>应用</p>
<ol>
<li><p>调用对象的原生方法，它将<code>hasOwnProperty</code>方法的原始定义放到<code>obj</code>对象上执行，这样无论<code>obj</code>上有没有同名方法，都不会影响结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖掉继承的 hasOwnProperty 方法</span></span><br><span class="line">obj.<span class="property">hasOwnProperty</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(obj, <span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p><code>Function.prototype.apply()</code></p>
<ol>
<li><p><code>apply</code>方法格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func.<span class="title function_">apply</span>(thisValue, [arg1, arg2, ...])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>apply</code>方法的作用与<code>call</code>方法类似，也是改变<code>this</code>指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数</p>
</li>
<li><p>应用</p>
<ol>
<li><p>找出数组最大元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, a) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将数组的空元素变为<code>undefined</code>，空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，但是不会跳过<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="string">&#x27;a&#x27;</span>, ,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, undefined, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>转换类似数组的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [1]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="number">0</span>: <span class="number">1</span>&#125;) <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;) <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定回调函数的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">o.<span class="property">f</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  o.<span class="property">f</span>.<span class="title function_">apply</span>(o);</span><br><span class="line">  <span class="comment">// 或者 o.f.call(o);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 的写法</span></span><br><span class="line">$(<span class="string">&#x27;#button&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, f);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p><code>Function.prototype.bind()</code></p>
<ol>
<li><p><code>bind()</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数</p>
</li>
<li><p><code>bind()</code>还可以接受更多的参数，将这些参数绑定原函数的参数</p>
</li>
<li><p><code>bind()</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象</p>
</li>
<li><p>注意点</p>
<ol>
<li><p>每一次返回一个新函数</p>
</li>
<li><p>结合回调函数使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, o.<span class="property">m</span>.<span class="title function_">bind</span>(o));</span><br><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, o.<span class="property">m</span>.<span class="title function_">bind</span>(o));<span class="comment">// 无效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的方法</span></span><br><span class="line"><span class="keyword">var</span> listener = o.<span class="property">m</span>.<span class="title function_">bind</span>(o);</span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">times</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">times</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>()</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>结合<code>call()</code>方法使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call()方法实质上是调用Function.prototype.call()方法</span></span><br><span class="line"><span class="keyword">var</span> slice = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>);</span><br><span class="line"><span class="title function_">slice</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://wangdoc.com/javascript/oop/this.html" title="网道-this关键字">网道-this关键字</a></p>
</li>
<li><p><a href="https://zh.javascript.info/object-methods" title="现代 JavaScript 教程-对象方法，“this”">现代 JavaScript 教程-对象方法，“this”</a></p>
</li>
<li><p><a href="https://zh.javascript.info/arrow-functions" title="现代 JavaScript 教程-深入理解箭头函数">现代 JavaScript 教程-深入理解箭头函数</a></p>
</li>
<li><p><a href="https://weread.qq.com/web/bookDetail/8c632230715c01a18c683d8" title="你不知道的JavaScript（上卷）-凯尔辛普森-微信读书 (qq.com)">你不知道的JavaScript（上卷）-凯尔辛普森-微信读书 (qq.com)</a></p>
</li>
<li><p><a href="https://weread.qq.com/web/bookDetail/751326d0720befab7514782" title="JavaScript高级程序设计（第4版）-马特·弗里斯比-微信读书 (qq.com)">JavaScript高级程序设计（第4版）-马特·弗里斯比-微信读书 (qq.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>new</tag>
        <tag>apply</tag>
        <tag>call</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title>原型&amp;原型链&amp;继承</title>
    <url>/2022/01/11/%E5%8E%9F%E5%9E%8B&amp;%E5%8E%9F%E5%9E%8B%E9%93%BE&amp;%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原型链和原型对象是js的核心，js以原型链的形式，保证函数或对象中的方法、属性可以让向下传递，按照面向对象的说法，这就是继承。而js通过原型链才得以实现函数或对象的继承</p>
<span id="more"></span>

<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ol>
<li><p>引用类型，都具有对象特性，即可自由扩展属性</p>
</li>
<li><p>引用类型，都有一个隐式原型 <code>__proto__</code> 属性，属性值是一个普通的对象</p>
</li>
<li><p>引用类型，隐式原型 <code>__proto__</code> 的属性值指向它的构造函数的显式原型 <code>prototype</code> 属性值</p>
</li>
<li><p>当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 <code>__proto__</code>（也就是它的构造函数的显式原型 <code>prototype</code>）中寻找&amp;#x20;</p>
</li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol>
<li><p>构造函数本身就是一个函数，与普通函数没有任何区别，不过为了规范一般将其首字母大写，</p>
</li>
<li><p><code>constructor</code> 返回创建实例对象时构造函数的引用，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串</p>
</li>
<li><p><code>Symbol</code> 是基本数据类型，但作为构造函数来说它并不完整，因为它不支持语法 <code>new Symbol()</code>，Chrome 认为其不是构造函数，如果要生成实例直接使用 <code>Symbol()</code> 即可，虽然是基本数据类型，但 <code>Symbol(123)</code> 实例可以获取 <code>constructor</code> 属性值</p>
</li>
</ol>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h2><ol>
<li><p>每个原型都有一个<code>constructor</code>属性指向关联的构造函数（并不一定）</p>
</li>
<li><p><code>constructor</code> 返回创建实例对象时构造函数的引用，继承于原型</p>
</li>
<li><p>对于引用类型来说 <code>constructor</code> 属性值是可以修改的，但是对于基本类型来说是只读的，<code>null</code> 和 <code>undefined</code> 没有 <code>constructor</code> 属性</p>
</li>
</ol>
<h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 <code>prototype</code></h2><ol>
<li><p>每个函数都有一个 <code>prototype</code> 属性，<code>prototype</code>是函数才会有的属性，这个属性是一个指针，指向一个对象而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，称为原型对象（<code>prototype object</code>）</p>
</li>
<li><p>函数的<code>prototype</code>属性是定义时自动添加的，默认为<code>&#123;&#125;</code></p>
</li>
</ol>
<h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h2><ol>
<li><p>每一个JavaScript对象(除了<code>null</code>)都具有的一个属性，叫<code>__proto__</code>，这个属性会指向该对象的原型</p>
</li>
<li><p><code>__proto__</code>是一个访问器属性（即 <code>getter</code> 函数和 <code>setter</code> 函数），通过它可以访问到对象的内部 <code>[[Prototype]]</code> (一个对象或 <code>null</code> )</p>
</li>
<li><p><code>[[Prototype]]</code> 是对象的一个内部属性，外部代码无法直接访问</p>
</li>
<li><p><code>[[prototype]]</code>和<code>__proto__</code>意义相同，均表示对象的内部属性，规范中表示一个对象的原型属性，后者则是在浏览器实现中指向对象原型</p>
</li>
<li><p>因为性能问题并不推荐使用，推荐使用 <code>Object.getPrototypeOf()</code></p>
</li>
</ol>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ol>
<li><p>每个对象拥有一个原型对象，通过 <code>__proto__</code> 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>。这种关系被称为原型链 (<code>prototype chain</code>)，通过原型链一个对象会拥有定义在其他对象中的属性和方法</p>
</li>
<li><p>原型链的构建依赖于 <code>__proto__</code></p>
</li>
<li><p>自有属性将遮蔽原型链上的同名属性</p>
</li>
<li><p><code>in</code>操作符会遍历原型链</p>
<p><img src="http://resource.muyiy.cn/image/2019-07-24-060312.jpg"></p>
</li>
</ol>
<h2 id="属性屏蔽"><a href="#属性屏蔽" class="headerlink" title="属性屏蔽"></a>属性屏蔽</h2><ul>
<li><p><code>myObject.foo = &#39;bar&#39;</code></p>
<ol>
<li><p>在<code>[[prototype]]</code>链上层存在<code>foo</code>属性，属性描述为<code>writable：true</code>，会在<code>myObject</code>创建<code>foo</code>属性</p>
</li>
<li><p>在<code>[[prototype]]</code>链上层存在<code>foo</code>属性，属性描述为<code>writable：false</code>，无法修改已有属性或创建<code>foo</code>属性，严格模式报错，否则会被忽略</p>
</li>
<li><p>在<code>[[prototype]]</code>链上层存在<code>foo</code>属性并且是一个<code>setter</code>，那么会一定调用这个<code>setter</code>，<code>foo</code>属性不会被创建</p>
</li>
</ol>
</li>
<li><p>使用<code>Object.defineProperty()</code>添加属性，不会受原型链的属性影响</p>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li><p>原型链继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;kevin&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span> () &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="title function_">getName</span>()) <span class="comment">// kevin</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点</p>
<ol>
<li>父类方法可以复用</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li><p>父类的所有引用属性被所有实例共享，更改一个子类的引用属性，其他子类也会受影响</p>
</li>
<li><p>子类型实例不能给父类型构造函数传参</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>借用构造函数(经典继承)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span> (name) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;kevin&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">name</span>); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">name</span>); <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点</p>
<ol>
<li><p>父类的引用属性不会被共享</p>
</li>
<li><p>子类构造函数中像父类构造函数传递参数</p>
</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>方法都在构造函数中定义，每次创建实例都会创建一遍方法</li>
</ol>
</li>
</ul>
</li>
<li><p>组合继承（原型链继承和经典继承）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性，既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span> (name, age) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line">child1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">name</span>); <span class="comment">// kevin</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">age</span>); <span class="comment">// 18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">colors</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;daisy&#x27;</span>, <span class="string">&#x27;20&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">name</span>); <span class="comment">// daisy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">age</span>); <span class="comment">// 20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">colors</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点</p>
<ol>
<li><p>父类的方法可以复用</p>
</li>
<li><p>可以在子类构造函数中向父类构造函数中传参</p>
</li>
<li><p>父类构造函数中的引用属性不会被共享</p>
</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>调用两次父构造函数</li>
</ol>
</li>
</ul>
</li>
<li><p>原型式继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对参数对象的一种浅复制</span></span><br><span class="line"><span class="comment">// ES5的Object.create()方法在只有第一个参数时，与这里的objectCopy()方法效果相同</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yhd&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;rose&quot;</span>],</span><br><span class="line">  <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">objectCopy</span>(person);</span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;wxb&quot;</span>;</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lily&quot;</span>);</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// wxb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">objectCopy</span>(person);</span><br><span class="line">person2.<span class="property">name</span> = <span class="string">&quot;gsr&quot;</span>;</span><br><span class="line">person2.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;kobe&quot;</span>);</span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;gsr&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>); <span class="comment">// [&quot;jack&quot;, &quot;tom&quot;, &quot;rose&quot;, &quot;lily&quot;, &quot;kobe&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点</p>
<ol>
<li>父类方法可复用</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li><p>父类的引用会被所有子类所共享</p>
</li>
<li><p>子类实例不能向父类传参</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>寄生式继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用原型式继承对一个目标对象进行浅复制，增强这个浅复制的能力</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title function_">objectCopy</span>(original);</span><br><span class="line">  clone.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&quot;yhd&quot;</span>,</span><br><span class="line">     <span class="attr">friends</span>: [<span class="string">&quot;rose&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jack&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">createAnother</span>(person);</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lily&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">friends</span>);</span><br><span class="line">person1.<span class="title function_">getName</span>(); <span class="comment">// yhd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">createAnother</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;tom&quot;, &quot;jack&quot;, &quot;lily&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>缺点</p>
<ol>
<li>跟借用构造函数模式一样，每次创建对象都会创建一遍方法</li>
</ol>
</li>
</ul>
</li>
<li><p>寄生组合式继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">child, parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title function_">objectCopy</span>(parent.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建对象</span></span><br><span class="line">  prototype.<span class="property">constructor</span> = child; <span class="comment">// 增强对象</span></span><br><span class="line">  <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&quot;rose&quot;</span>, <span class="string">&quot;lily&quot;</span>, <span class="string">&quot;tom&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>);</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;yhd&quot;</span>, <span class="number">23</span>);</span><br><span class="line">child1.<span class="title function_">sayAge</span>(); <span class="comment">// 23</span></span><br><span class="line">child1.<span class="title function_">sayName</span>(); <span class="comment">// yhd</span></span><br><span class="line">child1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;lily&quot;, &quot;tom&quot;, &quot;jack&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;yl&quot;</span>, <span class="number">22</span>)</span><br><span class="line">child2.<span class="title function_">sayAge</span>(); <span class="comment">// 22</span></span><br><span class="line">child2.<span class="title function_">sayName</span>(); <span class="comment">// yl</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;lily&quot;, &quot;tom&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点</p>
<ol>
<li><p>只调用一次父类构造函数</p>
</li>
<li><p>子类可以向父类传参</p>
</li>
<li><p>父类的引用属性不会被共享</p>
</li>
<li><p>原型链还能保持不变，父类方法可以复用</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://juejin.cn/post/6934498361475072014" title="面不面试的，你都得懂原型和原型链 - 掘金 (juejin.cn)">面不面试的，你都得懂原型和原型链 - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903782229213197" title="2019 面试准备 - JS 原型与原型链 - 掘金 (juejin.cn)">2019 面试准备 - JS 原型与原型链 - 掘金 (juejin.cn)</a></p>
</li>
<li><p>[Js中prototype、<a href="https://blog.csdn.net/qq_38722097/article/details/88046377" title="[prototype]]和">[prototype]]和</a><a href="https://blog.csdn.net/qq_38722097/article/details/88046377" title="proto"><strong>proto</strong></a><a href="https://blog.csdn.net/qq_38722097/article/details/88046377" title="的区别和用法_魍-的博客-CSDN博客_prototype">的区别和用法_魍-的博客-CSDN博客_prototype</a></p>
</li>
<li><p><a href="https://blog.csdn.net/xxxzzzyyybiu/article/details/113811647" title="浅谈原型与原型对象_ZaireSinatra的博客-CSDN博客_原型和原型对象">浅谈原型与原型对象_ZaireSinatra的博客-CSDN博客_原型和原型对象</a></p>
</li>
<li><p><a href="https://muyiy.cn/blog/5/5.1.html#%E5%BC%95%E8%A8%80" title="重新认识构造函数、原型和原型链 | 木易杨前端进阶 (muyiy.cn)">重新认识构造函数、原型和原型链 | 木易杨前端进阶 (muyiy.cn)</a></p>
</li>
<li><p><a href="https://github.com/mqyqingfeng/Blog/issues/16" title="JavaScript深入之继承的多种方式和优缺点 · Issue #16 · mqyqingfeng/Blog (github.com)">JavaScript深入之继承的多种方式和优缺点 · Issue #16 · mqyqingfeng&#x2F;Blog (github.com)</a></p>
</li>
<li><p>[JS继承 原型链继承、构造函数继承、组合继承、原型继承、寄生式继承、寄生组合继承 - 掘金 (<a href="http://juejin.cn/" title="juejin.cn">juejin.cn</a>)](</p>
</li>
<li><p><a href="https://github.com/yygmind/blog/issues/7" title="JavaScript常用八种继承方案 · Issue #7 · yygmind/blog (github.com)">JavaScript常用八种继承方案 · Issue #7 · yygmind&#x2F;blog (github.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>原型链</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>前端首页加载优化</title>
    <url>/2022/09/16/%E5%89%8D%E7%AB%AF%E9%A6%96%E9%A1%B5%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Vue</code>项目打包后<code>vendor.js</code>文件很大 如何对它进行优化以及开启<code>Vue</code>的压缩和<code>nginx</code>的<code>gzip</code> 配置，对首页加载速度进行优化</p>
<span id="more"></span>

<ol>
<li><p>路由加载</p>
</li>
<li><p>打包优化</p>
<ol>
<li><p>分析包大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build -- --report</span><br></pre></td></tr></table></figure>
</li>
<li><p>优化SVG图标</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set svg-sprite-loader</span></span><br><span class="line"><span class="comment">// 第一步：让其他svg loader不要对src/assets/imgs/svgs进行操作</span></span><br><span class="line">config.<span class="property">module</span>.<span class="title function_">rule</span>(<span class="string">&quot;svg&quot;</span>).<span class="property">exclude</span>.<span class="title function_">add</span>(<span class="title function_">resolve</span>(<span class="string">&quot;src/icons/svg&quot;</span>)).<span class="title function_">end</span>();</span><br><span class="line"><span class="comment">// 第二步：使用svg-sprite-loader 对 src/assets/imgs/svgs下的svg进行操作</span></span><br><span class="line">config.<span class="property">module</span></span><br><span class="line">  .<span class="title function_">rule</span>(<span class="string">&quot;icons&quot;</span>)</span><br><span class="line">  .<span class="title function_">test</span>(<span class="regexp">/\.svg$/</span>)</span><br><span class="line">  .<span class="property">include</span>.<span class="title function_">add</span>(<span class="title function_">resolve</span>(<span class="string">&quot;src/icons/svg&quot;</span>))</span><br><span class="line">  .<span class="title function_">end</span>()</span><br><span class="line">  .<span class="title function_">use</span>(<span class="string">&quot;svg-sprite-loader&quot;</span>)</span><br><span class="line">  .<span class="title function_">loader</span>(<span class="string">&quot;svg-sprite-loader&quot;</span>)</span><br><span class="line">  <span class="comment">//定义规则 使用时 &lt;svg class=&quot;icon&quot;&gt; &lt;use xlink:href=&quot;#icon-svg文件名&quot;&gt;&lt;/use&gt;  &lt;/svg&gt;</span></span><br><span class="line">  .<span class="title function_">options</span>(&#123;</span><br><span class="line">    <span class="attr">symbolId</span>: <span class="string">&quot;icon-[name]&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">end</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>排除打包，引用网络资源（<code>CDN</code>）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// index.html</span><br><span class="line"><span class="comment">&lt;!-- 引入样式 --&gt;</span></span><br><span class="line">&lt;% for(var css of htmlWebpackPlugin.options.cdn.css) &#123; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%=css%&gt;&quot;</span>&gt;</span></span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line"><span class="comment">&lt;!-- 引入JS --&gt;</span></span><br><span class="line">&lt;% for(var js of htmlWebpackPlugin.options.cdn.js) &#123; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&lt;%=js%&gt;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js 注释掉需要排除的依赖import ，并且注释掉 Vue.use</span></span><br><span class="line"><span class="comment">// import VCharts from &#x27;v-charts&#x27;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// import ElementUI from &quot;element-ui&quot;;</span></span><br><span class="line"><span class="comment">// import &quot;element-ui/lib/theme-chalk/index.css&quot;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Vue.use(ElementUI);</span></span><br><span class="line"><span class="comment">// Vue.use(VCharts);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">let</span> externals = &#123;</span><br><span class="line">  <span class="string">&#x27;vue&#x27;</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;element-ui&#x27;</span>: <span class="string">&#x27;ELEMENT&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;echarts&#x27;</span>: <span class="string">&#x27;echarts&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;v-charts&#x27;</span>: <span class="string">&#x27;VeIndex&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cdn = &#123;</span><br><span class="line">  <span class="attr">css</span>: [</span><br><span class="line">    <span class="string">&#x27;https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/element-ui/2.15.6/theme-chalk/index.css&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">js</span>: [</span><br><span class="line">    <span class="string">&#x27;https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/2.6.14/vue.js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/element-ui/2.15.6/index.js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/echarts/4.9.0-rc.1/echarts.min.js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/v-charts/1.19.0/index.js&#x27;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="title function_">chainWebpack</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    config.<span class="title function_">when</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>, <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      config.<span class="title function_">set</span>(<span class="string">&#x27;externals&#x27;</span>, externals)</span><br><span class="line">      config.<span class="title function_">plugin</span>(<span class="string">&#x27;html&#x27;</span>).<span class="title function_">tap</span>(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">        args[<span class="number">0</span>].<span class="property">cdn</span> = cdn</span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包去除<code>console.log</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">config.<span class="property">optimization</span>.<span class="title function_">minimizer</span>(<span class="string">&#x27;terser&#x27;</span>).<span class="title function_">tap</span>(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">  args[<span class="number">0</span>].<span class="property">terserOptions</span>.<span class="property">compress</span>.<span class="property">drop_console</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> args</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩图片</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在packgae.json 加上 “imagemin-gifsicle” ：&quot;^2.0.0&quot;</span></span><br><span class="line"><span class="comment">// npm install image-webpack-loader --save-dev</span></span><br><span class="line"></span><br><span class="line">config.<span class="property">module</span></span><br><span class="line">    .<span class="title function_">rule</span>(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    .<span class="title function_">test</span>(<span class="regexp">/\.(png|jpe?g|gif)(\?.*)?$/</span>)</span><br><span class="line">    .<span class="title function_">use</span>(<span class="string">&#x27;image-webpack-loader&#x27;</span>)</span><br><span class="line">    .<span class="title function_">loader</span>(<span class="string">&#x27;image-webpack-loader&#x27;</span>)</span><br><span class="line">    .<span class="title function_">options</span>(&#123;</span><br><span class="line">      <span class="comment">// 此处为ture的时候不会启用压缩处理,目的是为了开发模式下调试速度更快</span></span><br><span class="line">      <span class="attr">disable</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> == <span class="string">&#x27;development&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">end</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩<code>js</code>和<code>css</code></p>
</li>
<li><p>拆包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">config.<span class="property">optimization</span>.<span class="title function_">splitChunks</span>(&#123;</span><br><span class="line">  <span class="comment">// 拆包配置</span></span><br><span class="line">  <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>, <span class="comment">//三选一：&quot;initial&quot; 初始化，&quot;all&quot;(默认就是all)，&quot;async&quot;（动态加载）</span></span><br><span class="line">  <span class="attr">minSize</span>: <span class="number">30000</span>, <span class="comment">// 形成一个新代码块最小的体积,只有 &gt;= minSize 的bundle会被拆分出来 30000</span></span><br><span class="line">  <span class="attr">maxSize</span>: <span class="number">0</span>, <span class="comment">//拆分之前最大的数值，默认为0，即不做限制</span></span><br><span class="line">  <span class="attr">minChunks</span>: <span class="number">1</span>, <span class="comment">//引入次数，如果为2 那么一个资源最少被引用两次才可以被拆分出来</span></span><br><span class="line">  <span class="attr">maxAsyncRequests</span>: <span class="number">5</span>, <span class="comment">// 按需加载的最大并行请求数</span></span><br><span class="line">  <span class="attr">maxInitialRequests</span>: <span class="number">3</span>, <span class="comment">// 一个入口最大并行请求数</span></span><br><span class="line">  <span class="attr">automaticNameDelimiter</span>: <span class="string">&#x27;~&#x27;</span>, <span class="comment">// 文件名的连接符</span></span><br><span class="line">  <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">    <span class="comment">// node_modules模块包</span></span><br><span class="line">    <span class="attr">vendors</span>: &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;chunk-vendors&#x27;</span>,</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">      <span class="attr">priority</span>: -<span class="number">10</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 共享模块</span></span><br><span class="line">    <span class="attr">common</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;chunk-common&#x27;</span>,</span><br><span class="line">      <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">maxSize</span>: <span class="number">1024</span>, <span class="comment">//拆分之前最大的数值，默认为0，即不做限制</span></span><br><span class="line">      <span class="attr">priority</span>: -<span class="number">20</span>,</span><br><span class="line">      <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启<code>Gzip</code></p>
<ol>
<li><p><code>nginx</code>模块</p>
<ol>
<li><p>默认不存在<code>--with-http_gzip_static_module</code>模块 ，需要配置</p>
</li>
<li><p><code>./configure --with-http_gzip_static_module</code></p>
</li>
</ol>
</li>
<li><p><code>nginx.conf</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  root   /home/Vue/Vue_Manage; </span><br><span class="line">  index  index.html;</span><br><span class="line">  gzip_static on;</span><br><span class="line">  try_files $uri $uri/ /index.html; </span><br><span class="line">&#125;  </span><br><span class="line">location ~* \.(jpg|jpeg|png|gif|css|js|swf|mp3|avi|flv|xml|zip|rar)$ &#123;</span><br><span class="line">       root /home/Vue/Vue_Manage;</span><br><span class="line">       gzip_static on;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p><code> vue.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">config.<span class="title function_">plugin</span>(<span class="string">&#x27;CompressionWebpackPlugin&#x27;</span>).<span class="title function_">use</span>(<span class="keyword">new</span> <span class="title class_">CompressionWebpackPlugin</span>(&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(js)$/</span>, <span class="comment">// 匹配文件名</span></span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">10240</span>, <span class="comment">// 对超过10k的数据压缩</span></span><br><span class="line">  <span class="attr">minRatio</span>: <span class="number">0.8</span>,</span><br><span class="line">  <span class="attr">deleteOriginalAssets</span>: <span class="literal">true</span> <span class="comment">// 删除源文件</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>静态资源缓存</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>Vue</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>首页加载优化</tag>
      </tags>
  </entry>
  <entry>
    <title>执行上下文&amp;作用域&amp;作用域链&amp;闭包</title>
    <url>/2021/12/23/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87&amp;%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE&amp;%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习到JavaScript引擎处理一段代码的解析和执行顺序，变量的定义以及访问关系，又作用域链衍生出的闭包</p>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul>
<li><p>执行上下文是评估和执行 JavaScript 代码的环境的抽象概念</p>
</li>
<li><p>可以抽象的理解为一个<code>object</code></p>
</li>
</ul>
<h3 id="执行上下文重要属性"><a href="#执行上下文重要属性" class="headerlink" title="执行上下文重要属性"></a>执行上下文重要属性</h3><ul>
<li><p><code>变量对象(Variable object，VO)</code></p>
</li>
<li><p><code>作用域链(Scope chain)</code></p>
</li>
<li><p><code>this</code></p>
</li>
</ul>
<h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><ul>
<li><p>执行栈，也是“调用栈”</p>
</li>
<li><p>是一种拥有 <code>LIFO</code>（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文</p>
</li>
</ul>
<h3 id="执行上下文类型"><a href="#执行上下文类型" class="headerlink" title="执行上下文类型"></a>执行上下文类型</h3><ul>
<li><p>全局执行上下文</p>
</li>
<li><p>函数执行上下文</p>
</li>
<li><p>Eval 函数执行上下文</p>
</li>
</ul>
<h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><ul>
<li><p><code>变量对象</code>是与<code>执行上下文</code>相关的数据作用域，存储了在上下文中定义的<code>变量</code>和<code>函数声明</code></p>
</li>
<li><p>首先会处理<code>函数声明</code>，其次会处理<code>变量声明</code>，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</p>
</li>
<li><p>全局上下文</p>
<ul>
<li><code>全局对象</code></li>
</ul>
</li>
<li><p>函数上下文</p>
<ul>
<li><p><code>活动对象(activation object, AO)</code></p>
<ul>
<li><p>当函数被激活，那么一个活动对象就会被创建并且分配给执行上下文</p>
</li>
<li><p>活动对象由特殊对象<code>Arguments</code>初始化而成。随后，他被当做变量对象用于变量初始化</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><ul>
<li><p>全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符</p>
</li>
<li><p>通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性</p>
</li>
<li><p>在顶层 JavaScript 代码中，可以用关键字 <code>this</code> 引用全局对象，因为<code>全局对象</code>是<code>作用域链</code>的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询</p>
</li>
</ul>
<h3 id="Arguments-对象"><a href="#Arguments-对象" class="headerlink" title="Arguments 对象"></a>Arguments 对象</h3><ul>
<li><p>调用函数时，会为其创建一个<code>Arguments</code>对象，并自动初始化局部变量<code>arguments</code>，指代该<code>Arguments</code>对象</p>
</li>
<li><p>所有作为参数传入的值都会成为<code>Arguments</code>对象的数组元素</p>
</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li><p>作用域是指程序源代码中定义变量的区域</p>
</li>
<li><p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限</p>
</li>
<li><p>JavaScript 采用<code>词法作用域(lexical scoping)</code>，也就是静态作用域</p>
</li>
<li><p>通过 <code>var</code> 创建的变量只有函数作用域，而通过 <code>let</code> 和 <code>const</code> 创建的变量既有函数作用域，也有块作用域</p>
</li>
</ul>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul>
<li><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是<code>全局对象</code></p>
</li>
<li><p>这样由多个执行上下文的变量对象构成的链表就叫做作用域链</p>
<ul>
<li><p>创建函数，保存所有父变量对象到函数内部属性 <code>[[scope]]</code>中，<code>[[scope]]</code> 并不代表完整的作用域链</p>
</li>
<li><p>函数激活，进入函数上下文，创建 <code>AO</code> 后，将<code>AO</code>添加到作用链的前端</p>
</li>
</ul>
</li>
</ul>
<h3 id="嵌套作用域"><a href="#嵌套作用域" class="headerlink" title="嵌套作用域"></a>嵌套作用域</h3><ul>
<li><p>内部函数可以访问外部函数中定义的变量和形参</p>
</li>
<li><p>内部函数可以访问外部块中定义的变量</p>
</li>
</ul>
<h3 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h3><ul>
<li><p>词法作用域，函数的作用域在函数定义的时候就决定</p>
</li>
<li><p>动态作用域，函数的作用域是在函数调用的时候才决定</p>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li><p>闭包是一个可以访问外部作用域的内部函数</p>
</li>
<li><p>被闭包引用的外部作用域中的变量将一直存活直到闭包函数被销毁</p>
</li>
<li><p>闭包只存储外部变量的引用，而不会拷贝这些外部变量的值</p>
</li>
<li><p>通过闭包，我们可以创建拥有私有状态的函数，闭包使得状态被封装起来</p>
</li>
<li><p>这些被引用的变量直到闭包被销毁时才会被销毁</p>
</li>
</ul>
<h2 id="函数执行上下文的生命周期"><a href="#函数执行上下文的生命周期" class="headerlink" title="函数执行上下文的生命周期"></a>函数执行上下文的生命周期</h2><ul>
<li><p>声明函数</p>
<ul>
<li><p>作用域链</p>
<ul>
<li>保存所有父变量对象到函数内部属性 <code>[[scope]]</code>中，<code>[[scope]]</code> 并不代表完整的作用域链</li>
</ul>
<p><img src="http://blog.leapoahead.com/2015/09/15/js-closure/js_closure_2.png"></p>
</li>
</ul>
</li>
<li><p>创建阶段&#x2F;进入执行上下文</p>
<ul>
<li><p>在这个阶段中，执行上下文会分别创建<code>变量对象</code>，建立<code>作用域链</code>，以及确定 <code>this</code> 的指向</p>
<ul>
<li><p>活动对象</p>
<ul>
<li>活动对象初始化只包括 <code>Arguments</code> 对象，给变量对象添加形参、函数声明、变量声明等初始的属性值</li>
</ul>
</li>
<li><p>作用域链</p>
<ul>
<li><p>创建<code>作用域链</code>，复制函数<code>[[scope]]</code>属性</p>
</li>
<li><p>将活动对象压入函数作用域链顶端</p>
</li>
</ul>
<p><img src="http://blog.leapoahead.com/2015/09/15/js-closure/js_closure_3.png"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码执行阶段</p>
<ul>
<li><p>创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码</p>
<ul>
<li><p>活动对象</p>
<ul>
<li>再次修改活动对象的属性值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="函数执行上下文步骤"><a href="#函数执行上下文步骤" class="headerlink" title="函数执行上下文步骤"></a>函数执行上下文步骤</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> scope2 = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> scope2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkscope</span>();</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建checkscope函数，保存作用域链到内部属性[[scope]]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.<span class="property">VO</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 checkscope函数，创建 checkscope函数执行上下文，checkscope函数执行上下文被压入执行上下文栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ECStack</span> = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
</li>
<li><p>.checkscope函数并不立刻执行，开始做准备工作，</p>
<ol>
<li><p>复制函数[[scope]]属性创建作用域链</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    <span class="title class_">Scope</span>: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用 arguments创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">scope2</span>: <span class="literal">undefined</span></span><br><span class="line">    &#125;，</span><br><span class="line">    <span class="title class_">Scope</span>: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将活动对象压入 checkscope作用域链顶端</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">scope2</span>: <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title class_">Scope</span>: [<span class="variable constant_">AO</span>, [[<span class="title class_">Scope</span>]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>执行checkscope函数，随着函数的执行，修改 AO 的属性值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">scope2</span>: <span class="string">&#x27;local scope&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title class_">Scope</span>: [<span class="variable constant_">AO</span>, [[<span class="title class_">Scope</span>]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ECStack</span> = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p>[<a href="https://juejin.cn/post/6844903682283143181" title="译] 理解 JavaScript 中的执行上下文和执行栈 - 掘金 (juejin.cn)">译] 理解 JavaScript 中的执行上下文和执行栈 - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="https://github.com/mqyqingfeng/Blog/issues/4" title="JavaScript深入之执行上下文栈 · Issue #4 · mqyqingfeng/Blog (github.com)">JavaScript深入之执行上下文栈 · Issue #4 · mqyqingfeng&#x2F;Blog (github.com)</a></p>
</li>
<li><p><a href="https://github.com/kuitos/kuitos.github.io/issues/18" title="一道js面试题引发的思考 · Issue #18 · kuitos/kuitos.github.io">一道js面试题引发的思考 · Issue #18 · kuitos&#x2F;kuitos.github.io</a></p>
</li>
<li><p>[<a href="https://juejin.cn/post/6844903769646317576#heading-19" title="译]发现 JavaScript 中闭包的强大威力 - 掘金 (juejin.cn)">译]发现 JavaScript 中闭包的强大威力 - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="http://blog.leapoahead.com/2015/09/15/js-closure/" title="JavaScript闭包的底层运行机制 - 回田园 (leapoahead.com)">JavaScript闭包的底层运行机制 - 回田园 (leapoahead.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>执行上下文</tag>
        <tag>作用域</tag>
        <tag>作用域链</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>常见手写函数</title>
    <url>/2022/03/03/%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>手写功能无论是自我提升还是应付面试都十分有用</p>
<span id="more"></span>

<ul>
<li><p>对象部署iterator接口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>*() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> &#123; key, value &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(index &lt; keys.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="variable language_">this</span>[keys[index++]],</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="literal">undefined</span>,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>防抖</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>节流</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span> <span class="comment">// 上次触发时间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">if</span> (now - last &gt; delay) &#123;</span><br><span class="line">      last = now</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>深拷贝</p>
<ul>
<li><p><code>JSON</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不支持值为undefined、函数和循环引用的情况</span></span><br><span class="line"><span class="keyword">const</span> cloneObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (cache.<span class="title function_">has</span>(obj)) <span class="keyword">return</span> cache.<span class="title function_">get</span>(obj) <span class="comment">// 如果出现循环引用，则返回缓存的对象，防止递归进入死循环</span></span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>) <span class="comment">// 使用对象所属的构造函数创建一个新对象</span></span><br><span class="line">  cache.<span class="title function_">set</span>(obj, cloneObj) <span class="comment">// 缓存对象，用于循环引用的情况</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      cloneObj[key] = <span class="title function_">deepClone</span>(obj[key], cache) <span class="comment">// 递归拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>call</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>apply</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>bind</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">    fn = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context,</span><br><span class="line">      args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.map</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">map</span>(<span class="params">arr, mapCallback</span>) &#123;</span><br><span class="line">  <span class="comment">// 首先，检查传递的参数是否正确。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) || !arr.<span class="property">length</span> || <span class="keyword">typeof</span> mapCallback !== <span class="string">&#x27;function&#x27;</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 每次调用此函数时，我们都会创建一个 result 数组</span></span><br><span class="line">    <span class="comment">// 因为我们不想改变原始数组。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(<span class="title function_">mapCallback</span>(arr[i], i, arr)); </span><br><span class="line">      <span class="comment">// 将 mapCallback 返回的结果 push 到 result 数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.filter</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">filter</span>(<span class="params">arr, filterCallback</span>) &#123;</span><br><span class="line">  <span class="comment">// 首先，检查传递的参数是否正确。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) || !arr.<span class="property">length</span> || <span class="keyword">typeof</span> filterCallback !== <span class="string">&#x27;function&#x27;</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">     <span class="comment">// 每次调用此函数时，我们都会创建一个 result 数组</span></span><br><span class="line">     <span class="comment">// 因为我们不想改变原始数组。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// 检查 filterCallback 的返回值是否是真值</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">filterCallback</span>(arr[i], i, arr)) &#123; </span><br><span class="line">      <span class="comment">// 如果条件为真，则将数组元素 push 到 result 中</span></span><br><span class="line">        result.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// return the result array</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.reduce</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">arr, reduceCallback, initialValue</span>) &#123;</span><br><span class="line">  <span class="comment">// 首先，检查传递的参数是否正确。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) || !arr.<span class="property">length</span> || <span class="keyword">typeof</span> reduceCallback !== <span class="string">&#x27;function&#x27;</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue</span></span><br><span class="line">    <span class="keyword">let</span> hasInitialValue = initialValue !== <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">let</span> value = hasInitialValue ? initialValue : arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = hasInitialValue ? <span class="number">1</span> : <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">      value = <span class="title function_">reduceCallback</span>(value, arr[i], i, arr); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组去重</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种：Map记录</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quchong1</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newArr = []</span><br><span class="line">    arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pre.<span class="title function_">has</span>(next)) &#123;</span><br><span class="line">            pre.<span class="title function_">set</span>(next, <span class="number">1</span>)</span><br><span class="line">            newArr.<span class="title function_">push</span>(next)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;, <span class="keyword">new</span> <span class="title class_">Map</span>())</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：Set去重</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quchong2</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>new</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">//取得该方法的第一个参数(并删除第一个参数)，该参数是构造函数</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Constructor</span> = [].<span class="property">shift</span>.<span class="title function_">apply</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="comment">//将新对象的内部属性__proto__指向构造函数的原型，这样新对象就可以访问原型中的属性和方法</span></span><br><span class="line">    obj.<span class="property">__proto__</span> = <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="comment">//取得构造函数的返回值</span></span><br><span class="line">    <span class="keyword">var</span> ret = <span class="title class_">Constructor</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="comment">//如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&quot;object&quot;</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.create</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCreate</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = obj</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.assign</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>, <span class="string">&#x27;assign&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params">target, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标对象需要统一是引用数据类型，若不是会自动转换</span></span><br><span class="line">    <span class="keyword">const</span> to = <span class="title class_">Object</span>(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 每一个源对象</span></span><br><span class="line">      <span class="keyword">const</span> nextSource = args[i];</span><br><span class="line">      <span class="keyword">if</span> (nextSource !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用for...in和hasOwnProperty双重判断，确保只拿到本身的属性、方法（不包含继承的）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> nextKey <span class="keyword">in</span> nextSource) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(nextSource, nextKey)) &#123;</span><br><span class="line">            to[nextKey] = nextSource[nextKey];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 不可枚举</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myPromise</span>(<span class="params">constructor</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> self=<span class="variable language_">this</span>;</span><br><span class="line">    self.<span class="property">status</span>=<span class="string">&quot;pending&quot;</span> <span class="comment">//定义状态改变前的初始状态</span></span><br><span class="line">    self.<span class="property">value</span>=<span class="literal">undefined</span>;<span class="comment">//定义状态为resolved的时候的状态</span></span><br><span class="line">    self.<span class="property">reason</span>=<span class="literal">undefined</span>;<span class="comment">//定义状态为rejected的时候的状态</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="comment">//两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span></span><br><span class="line">       <span class="keyword">if</span>(self.<span class="property">status</span>===<span class="string">&quot;pending&quot;</span>)&#123;</span><br><span class="line">          self.<span class="property">value</span>=value;</span><br><span class="line">          self.<span class="property">status</span>=<span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">        <span class="comment">//两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span></span><br><span class="line">       <span class="keyword">if</span>(self.<span class="property">status</span>===<span class="string">&quot;pending&quot;</span>)&#123;</span><br><span class="line">          self.<span class="property">reason</span>=reason;</span><br><span class="line">          self.<span class="property">status</span>=<span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//捕获构造异常</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="title function_">constructor</span>(<span class="params">resolve,reject</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">       <span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义链式调用的then方法</span></span><br><span class="line">myPromise.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span>=<span class="keyword">function</span>(<span class="params">onFullfilled,onRejected</span>)&#123;</span><br><span class="line">   <span class="keyword">let</span> self=<span class="variable language_">this</span>;</span><br><span class="line">   <span class="keyword">switch</span>(self.<span class="property">status</span>)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;resolved&quot;</span>:</span><br><span class="line">        <span class="title function_">onFullfilled</span>(self.<span class="property">value</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;rejected&quot;</span>:</span><br><span class="line">        <span class="title function_">onRejected</span>(self.<span class="property">reason</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.all</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入不仅仅只有Array</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promiseAll</span> (args) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> promiseResults = [];</span><br><span class="line">    <span class="keyword">let</span> iteratorIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 已完成的数量，用于最终的返回，不能直接用完成数量作为iteratorIndex</span></span><br><span class="line">    <span class="comment">// 输出顺序和完成顺序是两码事</span></span><br><span class="line">    <span class="keyword">let</span> fullCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用于迭代iterator数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> args) &#123;</span><br><span class="line">      <span class="comment">// for of 遍历顺序，用于返回正确顺序的结果</span></span><br><span class="line">      <span class="comment">// 因iterator用forEach遍历后的key和value一样，所以必须存一份for of的 iteratorIndex</span></span><br><span class="line">      <span class="keyword">let</span> resultIndex = iteratorIndex;</span><br><span class="line">      iteratorIndex += <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 包一层，以兼容非promise的情况</span></span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(item).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        promiseResults[resultIndex] = res;</span><br><span class="line">        fullCount += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Iterator 接口的数据无法单纯的用length和size判断长度，不能局限于Array和 Map类型中</span></span><br><span class="line">        <span class="keyword">if</span> (fullCount === iteratorIndex) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(promiseResults)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理空 iterator 的情况</span></span><br><span class="line">    <span class="keyword">if</span>(iteratorIndex===<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="title function_">resolve</span>(promiseResults)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">Promise</span>.<span class="property">all</span>) <span class="title class_">Promise</span>.<span class="property">all</span> = promiseAll;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.race</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Promise.race accepts an array&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(arr[i]).<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>instanceof</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  left = left.<span class="property">__proto__</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span> || left === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (prototype === left)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    left = left.<span class="property">__proto__</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断数据是 null 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断数据是引用类型的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> valueClass = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value),</span><br><span class="line">      type = valueClass.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    type.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断数据是基本数据类型的情况和函数的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ajax</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装一个ajax请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myAjax</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="comment">//创建XMLHttpRequest对象</span></span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化参数的内容</span></span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    options.<span class="property">type</span> = (options.<span class="property">type</span> || <span class="string">&#x27;GET&#x27;</span>).<span class="title function_">toUpperCase</span>()</span><br><span class="line">    options.<span class="property">dataType</span> = options.<span class="property">dataType</span> || <span class="string">&#x27;json&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> params = options.<span class="property">data</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">type</span> === <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, options.<span class="property">url</span> + <span class="string">&#x27;?&#x27;</span> + params, <span class="literal">true</span>)</span><br><span class="line">        xhr.<span class="title function_">send</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.<span class="property">type</span> === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, options.<span class="property">url</span>, <span class="literal">true</span>)</span><br><span class="line">        xhr.<span class="title function_">send</span>(params)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收请求</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> status = xhr.<span class="property">status</span></span><br><span class="line">            <span class="keyword">if</span> (status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                options.<span class="property">success</span> &amp;&amp; options.<span class="title function_">success</span>(xhr.<span class="property">responseText</span>, xhr.<span class="property">responseXML</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                options.<span class="property">fail</span> &amp;&amp; options.<span class="title function_">fail</span>(status)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数柯里化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCurry</span>(<span class="params">fn, args</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取函数需要的参数长度</span></span><br><span class="line">  <span class="keyword">let</span> length = fn.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subArgs = args.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接得到现有的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      subArgs.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数的长度是否已经满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (subArgs.<span class="property">length</span> &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 如果满足，执行函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, subArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span></span><br><span class="line">      <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fn.<span class="property">length</span> &lt;= args.<span class="property">length</span> ? <span class="title function_">fn</span>(...args) : curry.<span class="title function_">bind</span>(<span class="literal">null</span>, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>jsonp</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">jsonp</span> = (<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">generateUrl</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> dataSrc = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">            <span class="keyword">if</span> (params.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">                dataSrc += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dataSrc += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataSrc&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> scriptEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">        scriptEle.<span class="property">src</span> = <span class="title function_">generateUrl</span>()</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(scriptEle)</span><br><span class="line">        <span class="variable language_">window</span>[callbackName] = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(data)</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">removeChild</span>(scriptEle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>手写</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据类型转换</title>
    <url>/2021/11/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>JavaScript</code>是一种动态类型语言，变量没有类型限制，可以随时赋予任意值，当我们进行某些操作时，变量可以进行类型之间的转换</p>
<span id="more"></span>


<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>原始类型</p>
<ol>
<li><p><code>undefined</code></p>
</li>
<li><p><code>null</code></p>
</li>
<li><p><code>boolean</code></p>
</li>
<li><p><code>string</code></p>
</li>
<li><p><code>number</code></p>
</li>
<li><p><code>symbol</code></p>
</li>
<li><p><code>bigInt</code></p>
</li>
</ol>
</li>
<li><p>对象类型</p>
<ol>
<li><code>object</code></li>
</ol>
</li>
</ul>
<h2 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><ol>
<li><p>原始值转布尔值</p>
<ul>
<li>当 <code>Boolean</code> 函数不传任何参数时，会返回 <code>false</code></li>
</ul>
<table>
<thead>
<tr>
<th align="center">数类型</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">undefined</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">null</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">“”</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">其他</td>
<td align="center">true</td>
</tr>
</tbody></table>
</li>
<li><p>原始值转数字</p>
<ul>
<li>无法被转换为数字，则返回 <code>NaN</code></li>
</ul>
<table>
<thead>
<tr>
<th align="center">数类型</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Undefined</td>
<td align="center">NaN</td>
</tr>
<tr>
<td align="center">Null</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">Boolean</td>
<td align="center">如果参数是 true，返回 1。参数为 false，返回 +0</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="center">返回与之相等的值</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">根据语法和转换规则</td>
</tr>
</tbody></table>
<ul>
<li><p><code>Number</code> 函数</p>
<ol>
<li><p>不传参数，返回 0</p>
</li>
<li><p>转换成一个整数或浮点数，忽略所有前导的 0</p>
</li>
<li><p>不是数字，结果都会返回 <code>NaN</code></p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;123&quot;</span>)<span class="comment">// 123</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;-123&quot;</span>) <span class="comment">// -123</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;1.2&quot;</span>) <span class="comment">// 1.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略前导0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;000123&quot;</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;-000123&quot;</span>) <span class="comment">// -123</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;0x11&quot;</span>)<span class="comment">// 17</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;0&quot;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot; &quot;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;123 123&quot;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;foo&quot;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;100a&quot;</span>)<span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>parseInt</code> &amp; <code>parseFloat</code></p>
<ol>
<li><p>字符串前缀是 <code>0x</code> 或者<code>0X</code>，<code>parseInt</code> 将其解释为十六进制数</p>
</li>
<li><p>都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容</p>
</li>
<li><p>如果第一个非空格字符是非法的数字直接量，将最终返回 <code>NaN</code></p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;3 abc&quot;</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;3.14 abc&quot;</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;-12.34&quot;</span>) <span class="comment">// -12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0xFF&quot;</span>) <span class="comment">// 255</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;.1&quot;</span>) <span class="comment">// 0.1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0.1&quot;</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>原始值转字符</p>
<table>
<thead>
<tr>
<th align="center">数类型</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Undefined</td>
<td align="center">“undefined”</td>
</tr>
<tr>
<td align="center">Null</td>
<td align="center">“null”</td>
</tr>
<tr>
<td align="center">Boolean</td>
<td align="center">如果参数是 true，返回 “true”。参数为 false，返回 “false”</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="center">根据语法和转换规则</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">返回与之相等的值</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">String</span>(-<span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">String</span>(<span class="title class_">NaN</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">String</span>(<span class="title class_">Infinity</span>) <span class="comment">// Infinity</span></span><br><span class="line"><span class="title class_">String</span>(-<span class="title class_">Infinity</span>) <span class="comment">// -Infinity</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原始值转对象</p>
<ol>
<li><p>原始值通过调用 <code>String()</code>、<code>Number()</code> 或者 <code>Boolean()</code> 构造函数，转换为它们各自的包装对象</p>
</li>
<li><p><code>null</code> 和 <code>undefined</code> 属于例外，当将它们用在期望是一个对象的地方都会造成一个类型错误 (<code>TypeError</code>) 异常，而不会执行正常的转换</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">typeof</span> a <span class="comment">// number</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Number</span>(a);</span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象转布尔值</p>
<ol>
<li><p>所有对象(包括数组和函数)都转换为 true</p>
</li>
<li><p>对于包装对象也是这样</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象转字符串和数字</p>
<ul>
<li><p>Object 的转换规则</p>
<ul>
<li>调用 <code>ToPrimitive</code> 方法，将其转为基本类型</li>
</ul>
</li>
<li><p><code>ToPrimitive</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ToPrimitive</span>(input[, <span class="title class_">PreferredType</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>input</code>，表示要处理的输入值</p>
</li>
<li><p><code>PreferredType</code>，非必填，表示希望转换成的类型，有两个值可以选，<code>Number</code> 或者 <code>String</code></p>
</li>
<li><p>如果传入的 <code>input</code> 是 <code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code> 类型，直接返回该值</p>
</li>
<li><p>处理步骤</p>
<ol>
<li><p>如果 obj 为 基本类型，直接返回</p>
</li>
<li><p>否则，调用 <code>valueOf</code> 方法，如果返回一个原始值，则将其返回</p>
</li>
<li><p>否则，调用 <code>toString</code> 方法，如果返回一个原始值，则将其返回</p>
</li>
<li><p>否则，抛出一个类型错误异常</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p><code>valueOf</code> 方法</p>
<ol>
<li><p>返回这个对象本身</p>
</li>
<li><p>原始类型包装对象返回对应原始类型</p>
</li>
<li><p>日期是一个例外，它会返回它的一个内容表示: 1970 年 1 月 1 日以来的毫秒数</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">typeof</span> num <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> num.<span class="title function_">valueOf</span>() <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2017</span>, <span class="number">4</span>, <span class="number">21</span>);</span><br><span class="line">date.<span class="title function_">valueOf</span>() <span class="comment">// 1495296000000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toString</code> 方法</p>
<ol>
<li><p>所有的对象除了 <code>null</code> 和 <code>undefined</code> 之外的任何值都具有 <code>toString</code> 方法</p>
</li>
<li><p>数组的 <code>toString</code> 方法将每个数组元素转换成一个字符串，并在元素之间添加逗号后合并成结果字符串</p>
</li>
<li><p>函数的 <code>toString</code> 方法返回源代码字符串</p>
</li>
<li><p>日期的 <code>toString</code> 方法返回一个可读的日期和时间字符串</p>
</li>
<li><p><code>RegExp</code> 的 <code>toString</code> 方法返回一个表示正则表达式直接量的字符串</p>
</li>
<li><p>其他对象的<code>toString</code> 方法会根据这个对象的[[class]]内部属性，返回`[object ${class}]`字符串</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123;&#125;).<span class="title function_">toString</span>()<span class="comment">// [object Object]</span></span><br><span class="line">[].<span class="title function_">toString</span>() <span class="comment">// &quot;&quot;</span></span><br><span class="line">[<span class="number">0</span>].<span class="title function_">toString</span>() <span class="comment">// &quot;0&quot;</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">toString</span>() <span class="comment">// 1,2,3</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">var</span> a = <span class="number">1</span>;&#125;).<span class="title function_">toString</span>() <span class="comment">// function ()&#123;var a = 1;&#125;</span></span><br><span class="line">(<span class="regexp">/\d+/g</span>).<span class="title function_">toString</span>() <span class="comment">// /\d+/g</span></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2010</span>, <span class="number">0</span>, <span class="number">1</span>)).<span class="title function_">toString</span>() <span class="comment">// Fri Jan 01 2010 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><ol>
<li><p>原始值转布尔类型</p>
<ul>
<li>逻辑判断或者有逻辑运算符时被触发（|| &amp;&amp; !）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">2</span>) &#123;&#125;      <span class="comment">// 逻辑判断触发隐式类型转换</span></span><br><span class="line">!!<span class="number">2</span>           <span class="comment">// 逻辑运算符触发隐式类型转换</span></span><br><span class="line"><span class="number">2</span> || <span class="string">&#x27;hello&#x27;</span>  <span class="comment">// 逻辑运算符触发隐式类型转换</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>转换为字符串</p>
<ul>
<li><p><code>+</code> 运算符并且有一个操作数是 string 类型时被触发，代表的字符串拼接</p>
<ol>
<li><p>有两边，一边是字符串，则会变成字符串拼接</p>
</li>
<li><p>有两边，一边是对象</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;123&#x27;</span>  <span class="comment">//&quot;1123&quot;</span></span><br><span class="line"><span class="number">1</span> + &#123;&#125;     <span class="comment">//&quot;1[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line">[]+&#123;&#125;       <span class="comment">//&quot;[object Object]&quot;</span></span><br><span class="line">&#123;&#125;+[]    <span class="comment">//&quot;[object Object]&quot;</span></span><br><span class="line"><span class="comment">// 在浏览器控制台输入将&#123;&#125;识别为代码块，&#123;&#125;+[]结果为&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Symbol</code> 类型转 <code>String</code> 类型是比较严格的，它只能被显式的转换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;symbol&#x27;</span>))  <span class="comment">// &#x27;Symbol(symbol)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span> + <span class="title class_">Symbol</span>(<span class="string">&#x27;symbol&#x27;</span>)  <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>转换为数字</p>
<ul>
<li><p>运算符</p>
<ol>
<li><p>比较操作（&gt;, &lt;, &lt;&#x3D;, &gt;&#x3D;）</p>
</li>
<li><p>按位操作（| &amp; ^ ~）</p>
</li>
<li><p>算数操作（- + * &#x2F; %）</p>
<ul>
<li>当 <code>+</code> 操作存在任意的操作数是 <code>string</code> 类型时，不会触发 <code>number</code> 类型的隐式转换</li>
</ul>
</li>
<li><p>一元 <code>+</code> 操作</p>
</li>
<li><p>非严格相等操作（&#x3D;&#x3D; 或者 !&#x3D; ）</p>
<ul>
<li><code>==</code> 操作两个操作数都是 <code>string</code> 类型时，不会发生 <code>number</code> 类型的隐式转换</li>
</ul>
</li>
</ol>
</li>
<li><p>不能将 <code>Symbol</code> 类型转为 <code>number</code> 类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;my symbol&#x27;</span>))    <span class="comment">// TypeError is thrown</span></span><br><span class="line">+<span class="title class_">Symbol</span>(<span class="string">&#x27;123&#x27;</span>)                 <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>特殊</p>
<ol>
<li><p>当将 <code>==</code> 应用于 <code>null</code> 或 <code>undefined</code> 时，不会发生数值转换</p>
<ul>
<li><code>null</code> 只等于 <code>null</code> 或 <code>undefined</code>，不等于其他任何值</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="number">0</span>               <span class="comment">// false, null is not converted to 0</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span>          <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span>            <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">undefined</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>       <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>NaN</code> 不等于任何值，包括它自己</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>  <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="对象与原始类型的相比较"><a href="#对象与原始类型的相比较" class="headerlink" title="对象与原始类型的相比较"></a>对象与原始类型的相比较</h2><ul>
<li><p><code>对象</code>与<code>原始类型</code>相比较时，会把<code>对象</code>按照<code>对象转换规则</code>转换成<code>原始类型</code>，再比较</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#125; == <span class="number">0</span>  <span class="comment">// false</span></span><br><span class="line">&#123;&#125; == <span class="string">&#x27;[object object]&#x27;</span>  <span class="comment">// true</span></span><br><span class="line">[] == <span class="literal">false</span>  <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] == <span class="string">&#x27;1,2,3&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="对象与对象相比较"><a href="#对象与对象相比较" class="headerlink" title="对象与对象相比较"></a>对象与对象相比较</h2><ul>
<li>如果两个对象指向同一个对象，相等操作符返回 <code>true</code>，否则为<code>false</code></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/85731460" title="帮你彻底弄懂 JavaScript 类型转换 - 知乎 (zhihu.com)">帮你彻底弄懂 JavaScript 类型转换 - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844904104402092039" title="JavaScript深入之头疼的类型转换(上) - 掘金 (juejin.cn)">JavaScript深入之头疼的类型转换(上) - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903907584376839" title="17道题彻底理解 JavaScript 中的类型转换 - 掘金 (juejin.cn)">17道题彻底理解 JavaScript 中的类型转换 - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="http://es5.github.io/#x9.3" title="Annotated ES5">Annotated ES5</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6956170676327677966#heading-5" title="通过面试题研究JavaScript数据类型转换 - 掘金 (juejin.cn)">通过面试题研究JavaScript数据类型转换 - 掘金 (juejin.cn)</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903557968166926" title="你所忽略的js隐式转换 - 掘金 (juejin.cn)">你所忽略的js隐式转换 - 掘金 (juejin.cn)</a></p>
</li>
<li><p>[带你撸一遍JS隐式转换细则 - 掘金 (<a href="http://juejin.cn/" title="juejin.cn">juejin.cn</a>)](</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>类型转换</tag>
      </tags>
  </entry>
</search>
