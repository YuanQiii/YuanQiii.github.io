<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuanqiii.cc","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言方便记忆和预览全部ES6特性">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6特性">
<meta property="og:url" content="https://yuanqiii.cc/2022/10/09/ES6%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="YuanQiii_Note">
<meta property="og:description" content="前言方便记忆和预览全部ES6特性">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-09T11:18:09.000Z">
<meta property="article:modified_time" content="2022-10-09T11:18:09.000Z">
<meta property="article:author" content="YuanQiii">
<meta property="article:tag" content="ES6">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yuanqiii.cc/2022/10/09/ES6%E7%89%B9%E6%80%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>ES6特性 | YuanQiii_Note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">YuanQiii_Note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanqiii.cc/2022/10/09/ES6%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YuanQiii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YuanQiii_Note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ES6特性
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-09 19:18:09" itemprop="dateCreated datePublished" datetime="2022-10-09T19:18:09+08:00">2022-10-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>方便记忆和预览全部<code>ES6</code>特性</p>
<span id="more"></span>

<h1 id="ES6特性"><a href="#ES6特性" class="headerlink" title="ES6特性"></a>ES6特性</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ol>
<li><p><code>const</code>命令：声明常量</p>
</li>
<li><p><code>let</code>命令：声明变量</p>
</li>
<li><p>注意</p>
<ol>
<li><p>块级作用域</p>
</li>
<li><p>不允许重复声明</p>
</li>
<li><p>不存在变量提升</p>
</li>
<li><p>暂时性死区</p>
</li>
</ol>
</li>
<li><p>共享内存和原子操作：由全局对象<code>SharedArrayBuffer</code>和<code>Atomics</code>实现，将数据存储在一块共享内存空间中，这些数据可在JS主线程和web-worker线程之间共享</p>
</li>
<li><p><code>globalThis</code>：作为顶层对象，指向全局环境下的<code>this</code></p>
<ul>
<li><p><code>Browser</code>：顶层对象是<code>window</code></p>
</li>
<li><p><code>Node</code>：顶层对象是<code>global</code></p>
</li>
<li><p><code>WebWorker</code>：顶层对象是<code>self</code></p>
</li>
<li><p>以上三者：通用顶层对象是<code>globalThis</code></p>
</li>
</ul>
</li>
</ol>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ol>
<li><p>字符串解构：<code>const [a, b, c, d, e] = &quot;hello&quot;</code></p>
</li>
<li><p>数值解构：<code>const &#123; toString: s &#125; = 123</code></p>
</li>
<li><p>布尔解构：<code>const &#123; toString: b &#125; = true</code></p>
</li>
<li><p>对象解构</p>
<ol>
<li><p>形式：<code>const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125;</code></p>
</li>
<li><p>默认：<code>const &#123; x, y = 2 &#125; = &#123; x: 1 &#125;</code></p>
</li>
<li><p>改名：<code>const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125;</code></p>
</li>
<li><p>嵌套：<code>const &#123;x: [&#123;y&#125;]&#125; = &#123;x: [&#123;y: 1&#125;]&#125;</code></p>
</li>
</ol>
</li>
<li><p>数组解构</p>
<ol>
<li><p>规则：数据结构具有<code>Iterator</code>接口可采用数组形式的解构赋值</p>
</li>
<li><p>形式：<code>const [x, y] = [1, 2]</code></p>
</li>
<li><p>默认：<code>const [x, y = 2] = [1]</code></p>
</li>
</ol>
</li>
<li><p>函数参数解构</p>
<ol>
<li><p>数组解构：<code>function Func([x = 0, y = 1]) &#123;&#125;</code></p>
</li>
<li><p>对象解构：<code>function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125;</code></p>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>交换变量值：<code>[x, y] = [y, x]</code></p>
</li>
<li><p>返回函数多个值：<code>const [x, y, z] = Func()</code></p>
</li>
<li><p>定义函数参数：<code>Func([1, 2])</code></p>
</li>
<li><p>提取JSON数据：<code>const &#123; name, version &#125; = packageJson</code></p>
</li>
<li><p>定义函数参数默认值：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></p>
</li>
<li><p>遍历Map结构：<code>for (let [k, v] of Map) &#123;&#125;</code></p>
</li>
<li><p>输入模块指定属性和方法：<code>const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;)</code></p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</p>
</li>
<li><p>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</p>
</li>
<li><p>解构默认值生效条件：属性值严格等于<code>undefined</code></p>
</li>
<li><p>解构遵循匹配模式</p>
</li>
<li><p>解构不成功时变量的值等于<code>undefined</code></p>
</li>
<li><p><code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</p>
</li>
</ol>
</li>
</ol>
<h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h2><ol>
<li><p><code>Unicode</code>表示法：<code>&#39;\uxxxx&#39;</code></p>
</li>
<li><p>字符串遍历：可通过<code>for-of</code>遍历字符串</p>
</li>
<li><p>字符串模板：可单行可多行可插入变量的增强版字符串以及可以换行<code>&#39;$&#123;xxx&#125;&#39;</code></p>
</li>
<li><p>标签模板：函数参数的特殊调用<code>alert`hello`</code> → <code>alert([&#39;hello&#39;])</code>，第一个参数始终都是分割好的字符串数组。其余的参数是模板表达式的值</p>
</li>
<li><p>放松对标签模板里字符串转义的限制：遇到不合法的字符串转义返回<code>undefined</code>，并且从<code>raw</code>上可获取原字符串</p>
</li>
<li><p>直接输入<code>U+2028</code><strong>和</strong><code>U+2029</code>：字符串可直接输入行分隔符和段分隔符</p>
</li>
<li><p><code>JSON.stringify()</code>改造：可返回不符合<code>UTF-8</code>标准的字符串</p>
</li>
<li><p><code>trimStart()</code>：消除字符串头部空格，返回新字符串</p>
</li>
<li><p><code>trimEnd()</code>：消除字符串尾部空格，返回新字符串</p>
</li>
<li><p><code>String.raw()</code>：返回把字符串所有变量替换且对斜杠进行转义的结果</p>
</li>
<li><p><code>String.fromCodePoint()</code>：返回码点对应字符</p>
</li>
<li><p><code>codePointAt()</code>：返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</p>
</li>
<li><p><code>normalize()</code>：把字符的不同表示方法统一为同样形式，返回新字符串(Unicode正规化)</p>
</li>
<li><p><code>repeat()</code>：把字符串重复n次，返回新字符串</p>
</li>
<li><p><code>matchAll()</code>：返回正则表达式在字符串的所有匹配</p>
</li>
<li><p><code>includes()</code>：是否存在指定字符串</p>
</li>
<li><p><code>startsWith()</code>：是否存在字符串头部指定字符串</p>
</li>
<li><p><code>endsWith()</code>：是否存在字符串尾部指定字符串</p>
</li>
<li><p><code>padStart()</code>：把指定字符串填充到字符串头部，参数是新字符串的总长度，如果这个长度比原来的字符串长度短，那么不会填充，返回新字符串</p>
</li>
<li><p><code>padEnd()</code>：把指定字符串填充到字符串尾部，参数是新字符串的总长度，如果这个长度比原来的字符串长度短，那么不会填充，返回新字符串</p>
</li>
<li><p>注意</p>
<ol>
<li>以上扩展方法均可作用于由4个字节储存的<code>Unicode</code>字符上</li>
</ol>
</li>
</ol>
<h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h2><ol>
<li><p>二进制表示法：<code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</p>
</li>
<li><p>八进制表示法：<code>0o或0O开头</code>表示八进制(<code>0oXX</code>或<code>0OXX</code>)</p>
</li>
<li><p><code>Number.EPSILON</code>：数值最小精度</p>
</li>
<li><p><code>Number.MIN_SAFE_INTEGER</code>：最小安全数值(<code>-2^53</code>)</p>
</li>
<li><p><code>Number.MAX_SAFE_INTEGER</code>：最大安全数值(<code>2^53</code>)</p>
</li>
<li><p><code>Number.parseInt()</code>：返回转换值的整数部分</p>
</li>
<li><p><code>Number.parseFloat()</code>：返回转换值的浮点数部分</p>
</li>
<li><p><code>Number.isFinite()</code>：是否为有限数值</p>
</li>
<li><p><code>Number.isNaN()</code>：是否为NaN</p>
</li>
<li><p><code>Number.isInteger()</code>：是否为整数</p>
</li>
<li><p><code>Number.isSafeInteger()</code>：是否在数值安全范围内</p>
</li>
<li><p><code>Math.trunc()</code>：返回数值整数部分</p>
</li>
<li><p><code>Math.sign()</code>：返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</p>
</li>
<li><p><code>Math.cbrt()</code>：返回数值立方根</p>
</li>
<li><p><code>Math.clz32()</code>：返回数值的32位无符号整数形式</p>
</li>
<li><p><code>Math.imul()</code>：返回两个数值相乘</p>
</li>
<li><p><code>Math.fround()</code>：返回数值的32位单精度浮点数形式</p>
</li>
<li><p><code>Math.hypot()</code>：返回所有数值平方和的平方根</p>
</li>
<li><p><code>Math.expm1()</code>：返回<code>e^n - 1</code></p>
</li>
<li><p><code>Math.log1p()</code>：返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</p>
</li>
<li><p><code>Math.log10()</code>：返回以10为底的n的对数</p>
</li>
<li><p><code>Math.log2()</code>：返回以2为底的n的对数</p>
</li>
<li><p><code>Math.sinh()</code>：返回n的双曲正弦</p>
</li>
<li><p><code>Math.cosh()</code>：返回n的双曲余弦</p>
</li>
<li><p><code>Math.tanh()</code>：返回n的双曲正切</p>
</li>
<li><p><code>Math.asinh()</code>：返回n的反双曲正弦</p>
</li>
<li><p><code>Math.acosh()</code>：返回n的反双曲余弦</p>
</li>
<li><p><code>Math.atanh()</code>：返回n的反双曲正切</p>
</li>
<li><p><code>Math.pow()</code>：返回数值求幂</p>
</li>
<li><p><code>BigInt</code>：任何位数的整数(新增的数据类型，使用<code>n</code>结尾)</p>
<ol>
<li><p><code>BigInt()</code>：转换普通数值为<code>BigInt</code>类型</p>
</li>
<li><p><code>BigInt.asUintN()</code>：转换<code>BigInt</code>为<code>0</code>到<code>2n-1</code>之间对应的值</p>
</li>
<li><p><code>BigInt.asIntN()</code>：转换<code>BigInt</code>为<code>-2n-1</code> 到<code>2n-1-1</code></p>
</li>
<li><p><code>BigInt.parseInt()</code>：近似于<code>Number.parseInt()</code>，将一个字符串转换成指定进制的<code>BigInt</code>类型</p>
</li>
<li><p>注意</p>
<ol>
<li><p><code>BigInt</code>同样可使用各种进制表示，都要加上后缀</p>
</li>
<li><p><code>BigInt</code>与普通整数是两种值，它们之间并不相等</p>
</li>
<li><p><code>typeof</code>运算符对于<code>BigInt</code>类型的数据返回<code>bigint</code></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><ol>
<li><p>简洁表示法：直接写入变量和函数作为对象的属性和方法(<code>&#123; prop, method() &#123;&#125; &#125;</code>)</p>
</li>
<li><p>属性名表达式：字面量定义对象时使用<code>[]</code>定义键(<code>[prop]</code>，不能与上同时使用)</p>
</li>
<li><p>属性的可枚举性和遍历：描述对象的<code>enumerable</code></p>
</li>
<li><p><code>super</code>关键字：指向当前对象的原型对象(只能用在对象的简写方法中<code>method() &#123;&#125;</code>)</p>
</li>
<li><p><code>Object.is()</code>：对比两值是否相等</p>
</li>
<li><p><code>Object.assign()</code>：合并对象(浅拷贝)，返回原对象</p>
</li>
<li><p><code>Object.getPrototypeOf()</code>：返回对象的原型对象</p>
</li>
<li><p><code>Object.setPrototypeOf()</code>：设置对象的原型对象</p>
</li>
<li><p><code>proto</code>：返回或设置对象的原型对象</p>
</li>
<li><p><code>Object.getOwnPropertyDescriptors()</code>：返回对象所有自身属性(非继承属性)的描述对象</p>
</li>
<li><p><code>Object.values()</code>：返回以值组成的数组</p>
</li>
<li><p><code>Object.entries()</code>：返回以键和值组成的数组</p>
</li>
<li><p><code>Object.fromEntries()</code>：返回以键和值组成的对象(<code>Object.entries()</code>的逆操作)</p>
</li>
<li><p>属性遍历</p>
<ol>
<li><p>描述</p>
<ol>
<li><p>自身</p>
</li>
<li><p>可继承</p>
</li>
<li><p>可枚举</p>
</li>
<li><p>非枚举</p>
</li>
<li><p><code>Symbol</code></p>
</li>
</ol>
</li>
<li><p>遍历</p>
<ol>
<li><p><code>for-in</code>：遍历对象<strong>自身可继承可枚举</strong>属性</p>
</li>
<li><p><code>Object.keys()</code>：返回对象<strong>自身可枚举</strong>属性键组成的数组</p>
</li>
<li><p><code>Object.getOwnPropertyNames()</code>：返回对象<strong>自身非Symbol</strong>属性键组成的数组</p>
</li>
<li><p><code>Object.getOwnPropertySymbols()</code>：返回对象<strong>自身Symbol</strong>属性键组成的数组</p>
</li>
<li><p><code>Reflect.ownKeys()</code>：返回对象<strong>自身全部</strong>属性键组成的数组</p>
</li>
</ol>
</li>
<li><p>规则</p>
<ol>
<li><p>首先遍历所有数值键，按照数值升序排列</p>
</li>
<li><p>其次遍历所有字符串键，按照加入时间升序排列</p>
</li>
<li><p>最后遍历所有<code>Symbol</code>键，按照加入时间升序排列</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>扩展运算符(<code>...</code>)：转换对象为用逗号分隔的参数序列(<code>&#123; ...obj &#125;</code>，相当于<code>rest/spread</code>参数的逆运算)</p>
<ol>
<li><p>克隆对象：<code>const obj = &#123; __proto__: Object.getPrototypeOf(obj1), ...obj1 &#125;</code></p>
</li>
<li><p>合并对象：<code>const obj = &#123; ...obj1, ...obj2 &#125;</code></p>
</li>
<li><p>转换字符串为对象：<code>&#123; ...&quot;hello&quot; &#125;</code></p>
</li>
<li><p>转换数组为对象：<code>&#123; ...[1, 2] &#125;</code></p>
</li>
<li><p>与对象解构赋值结合：<code>const &#123; x, ...rest/spread &#125; = &#123; x: 1, y: 2, z: 3 &#125;</code>(不能复制继承自原型对象的属性)</p>
</li>
<li><p>修改现有对象部分属性：<code>const obj = &#123; x: 1, ...&#123; x: 2 &#125; &#125;</code></p>
</li>
</ol>
</li>
<li><p>&amp;#x20;链判断操作符(<code>?.</code>)：是否存在对象属性(不存在返回<code>undefined</code>且不再往下执行)</p>
<ol>
<li><p>对象属性：<code>obj?.prop</code>、<code>obj?.[expr]</code></p>
</li>
<li><p>函数调用：<code>func?.(...args)</code></p>
</li>
</ol>
</li>
<li><p>空判断操作符(<code>??</code>)：是否值为<code>undefined</code>或<code>null</code>，是则使用默认值</p>
</li>
</ol>
<h2 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h2><ol>
<li><p>扩展运算符(<code>...</code>)：转换数组为用逗号分隔的参数序列(<code>[...arr]</code>，相当于<code>rest/spread参数</code>的逆运算)</p>
</li>
<li><p><code>Array.from()</code></p>
<ol>
<li><p>转换具有<code>Iterator</code>接口的数据结构为真正数组，返回新数组</p>
</li>
<li><p>可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
</li>
<li><p>类数组对象：包含<code>length</code>的对象、<code>Arguments</code>对象、<code>NodeList</code>对象</p>
</li>
<li><p>可遍历对象：<code>String</code>、<code>Set</code>结构、<code>Map</code>结构、<code>Generator</code>函数</p>
</li>
</ol>
</li>
<li><p><code>Array.of()</code>：转换一组值为真正数组，返回新数组</p>
</li>
<li><p><code>copyWithin()</code>：把指定位置的成员复制到其他位置，返回原数组</p>
</li>
<li><p><code>find()</code>：返回第一个符合条件的成员</p>
</li>
<li><p><code>findIndex()</code>：返回第一个符合条件的成员索引值</p>
</li>
<li><p><code>fill()</code>：根据指定值填充整个数组，返回原数组</p>
</li>
<li><p><code>keys()</code>：返回以索引值为遍历器的对象</p>
</li>
<li><p><code>values()</code>：返回以属性值为遍历器的对象</p>
</li>
<li><p><code>entries()</code>：返回以索引值和属性值为遍历器的对象</p>
</li>
<li><p><code>includes()</code>：是否存在指定成员，返回布尔值</p>
</li>
<li><p><code>sort()</code>稳定性：排序关键字相同的项目其排序前后的顺序不变，默认为稳定</p>
</li>
<li><p><code>flat()</code>：扁平化数组，返回新数组，不改变原数组</p>
</li>
<li><p><code>flatMap()</code>：对原数组的每个成员执行一个函数，返回新数组(只能展开一层数组)，不改变原数组</p>
</li>
<li><p>数组空位：ES6明确将数组空位转为<code>undefined</code>(空位处理规不一，建议避免出现)</p>
</li>
<li><p>应用</p>
<ol>
<li><p>克隆数组：<code>const arr = [...arr1]</code></p>
</li>
<li><p>合并数组：<code>const arr = [...arr1, ...arr2]</code></p>
</li>
<li><p>拼接数组：<code>arr.push(...arr1)</code></p>
</li>
<li><p>代替<code>apply</code>：<code>Math.max.apply(null, [x, y])</code> → <code>Math.max(...[x, y])</code></p>
</li>
<li><p>转换字符串为数组：<code>[...&quot;hello&quot;]</code></p>
</li>
<li><p>转换类数组对象为数组：<code>[...Arguments, ...NodeList]</code></p>
</li>
<li><p>转换可遍历对象为数组：<code>[...String, ...Set, ...Map, ...Generator]</code></p>
</li>
<li><p>与数组解构赋值结合：<code>const [x, ...rest/spread] = [1, 2, 3]</code></p>
</li>
<li><p>计算<code>Unicode</code>字符长度：<code>Array.from(&quot;hello&quot;).length</code> → <code>[...&quot;hello&quot;].length</code></p>
</li>
</ol>
</li>
<li><p>注意</p>
<ul>
<li>使用<code>keys()</code>、<code>values()</code>、<code>entries()</code>返回的遍历器对象，可用<code>for-of</code>自动遍历或<code>next()</code>手动遍历</li>
</ul>
</li>
</ol>
<h2 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h2><ol>
<li><p>参数默认值：为函数参数指定默认值</p>
<ol>
<li><p>形式：<code>function Func(x = 1, y = 2) &#123;&#125;</code></p>
</li>
<li><p>参数赋值：惰性求值(函数调用后才求值)</p>
</li>
<li><p>参数位置：尾参数</p>
</li>
<li><p>参数作用域：函数作用域</p>
</li>
<li><p>声明方式：默认声明</p>
</li>
<li><p><code>length</code>：返回没有指定默认值的参数个数</p>
</li>
<li><p>与解构赋值默认值结合：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></p>
</li>
<li><p>注意</p>
<ol>
<li><p>使用参数默认值时，函数不能有同名参数</p>
</li>
<li><p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明</p>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>指定某个参数不得省略，省略即抛出错误：<code>function Func(x = throwMissing()) &#123;&#125;</code></p>
</li>
<li><p>将参数默认值设为<code>undefined</code>，表明此参数可省略：<code>Func(undefined, 1)</code></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><code>rest/spread</code>参数(<code>...</code>**)**：返回函数多余参数</p>
<ol>
<li><p>形式：以数组的形式存在，之后不能再有其他参数</p>
</li>
<li><p>作用：代替<code>Arguments</code>对象</p>
</li>
<li><p><code>length</code>：返回没有指定默认值的参数个数但不包括<code>rest/spread参数</code></p>
</li>
</ol>
</li>
<li><p>函数参数尾逗号：允许函数最后一个参数有尾逗号</p>
</li>
<li><p>严格模式</p>
<ol>
<li>应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</li>
</ol>
</li>
<li><p><code>name</code>属性：返回函数的函数名</p>
<ol>
<li><p>将匿名函数赋值给变量：<code>空字符串</code>(ES5)、<code>变量名</code>(ES6)</p>
</li>
<li><p>将具名函数赋值给变量：<code>函数名</code>(ES5和ES6)</p>
</li>
<li><p><code>bind</code>返回的函数：<code>bound 函数名</code>(ES5和ES6)</p>
</li>
<li><p><code>Function</code>构造函数返回的函数实例：<code>anonymous</code>(ES5和ES6)</p>
</li>
</ol>
</li>
<li><p><code>toString()</code>改造：返回函数原始代码(与编码一致)</p>
</li>
<li><p><code>catch()</code>参数可省略：<code>catch()</code>中的参数可省略</p>
</li>
<li><p>箭头函数 **(<strong><code>=&gt;</code></strong>) **：函数简写</p>
<ol>
<li><p>无参数：<code>() =&gt; &#123;&#125;</code></p>
</li>
<li><p>单个参数：<code>x =&gt; &#123;&#125;</code></p>
</li>
<li><p>多个参数：<code>(x, y) =&gt; &#123;&#125;</code></p>
</li>
<li><p>解构参数：<code>(&#123;x, y&#125;) =&gt; &#123;&#125;</code></p>
</li>
<li><p>嵌套使用：部署管道机制</p>
</li>
<li><p><code>this</code>指向固定化</p>
<ol>
<li><p>并非因为内部有绑定<code>this</code>的机制，而是根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code></p>
</li>
<li><p>因为没有<code>this</code>，因此不能用作构造函数</p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>函数体内的<code>this</code>是<code>定义时所在的对象</code>而不是<code>使用时所在的对象</code></p>
</li>
<li><p>可让<code>this</code>指向固定化，这种特性很有利于封装回调函数</p>
</li>
<li><p>不可当作<code>构造函数</code>，因此箭头函数不可使用<code>new</code>命令</p>
</li>
<li><p>不可使用<code>yield</code>命令，因此箭头函数不能用作<code>Generator</code>函数</p>
</li>
<li><p>不可使用<code>Arguments</code>对象，此对象在函数体内不存在(可用<code>rest/spread</code>参数代替)</p>
</li>
<li><p>返回对象时必须在对象外面加上括号</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>尾调用优化：只保留内层函数的调用帧</p>
<ul>
<li><p>尾调用</p>
<ul>
<li><p>定义：某个函数的最后一步是调用另一个函数</p>
</li>
<li><p>形式：<code>function f(x) &#123; return g(x); &#125;</code></p>
</li>
</ul>
</li>
<li><p>尾递归</p>
<ul>
<li><p>定义：函数尾调用自身</p>
</li>
<li><p>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</p>
</li>
<li><p>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h2><ol>
<li><p>变更<code>RegExp</code>构造函数入参：允许首参数为正则对象，尾参数为正则修饰符(返回的正则表达式会忽略原正则表达式的修饰符)</p>
</li>
<li><p>正则方法调用变更：字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></p>
</li>
<li><p><code>u</code>修饰符：<code>Unicode</code>模式修饰符，正确处理<code>\uFFFF</code>的<code>Unicode字符</code></p>
<ul>
<li><p>点字符(<code>.</code>)</p>
</li>
<li><p><code>Unicode</code>表示法</p>
</li>
<li><p>量词</p>
</li>
<li><p>预定义模式</p>
</li>
<li><p><code>i</code>修饰符</p>
</li>
<li><p>转义</p>
</li>
</ul>
</li>
<li><p><code>y</code>修饰符：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与<code>g</code>修饰符作用类似)</p>
</li>
<li><p><code>s</code>修饰符：<code>dotAll</code>模式修饰符，使<code>.</code>匹配任意单个字符(<code>dotAll</code>模式)</p>
</li>
<li><p><code>dotAll</code>：是否设置<code>s</code>修饰符</p>
</li>
<li><p><code>unicode</code>：是否设置<code>u</code>修饰符</p>
</li>
<li><p><code>Unicode</code>属性转义：匹配符合<code>Unicode</code>某种属性的所有字符</p>
<ul>
<li><p>正向匹配：<code>\p&#123;PropRule&#125;</code></p>
</li>
<li><p>反向匹配：<code>\P&#123;PropRule&#125;</code></p>
</li>
<li><p>限制：<code>\p&#123;...&#125;</code>和<code>\P&#123;...&#125;</code>只对<code>Unicode</code>字符有效，使用时需加上<code>u</code>修饰符</p>
</li>
</ul>
</li>
<li><p><code>sticky</code>：是否设置<code>y</code>修饰符</p>
</li>
<li><p><code>flags</code>：返回正则表达式的修饰符</p>
</li>
<li><p><code>matchAll()</code>：返回所有匹配的遍历器</p>
</li>
<li><p>后行断言：<code>x</code>只有在<code>y</code>后才匹配</p>
</li>
<li><p>后行否定断言：<code>x</code>只有不在<code>y</code>后才匹配</p>
</li>
<li><p>具名组匹配：为每组匹配指定名字(<code>?&lt;GroupName&gt;</code>)</p>
<ol>
<li><p>形式：<code>str.exec().groups.GroupName</code></p>
</li>
<li><p>解构赋值替换</p>
<ol>
<li><p>声明：<code>const time = &quot;2017-09-11&quot;</code>、<code>const regexp = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</code></p>
</li>
<li><p>匹配：<code>time.replace(regexp, &quot;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&quot;)</code></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><ol>
<li><p>定义：独一无二的值</p>
</li>
<li><p>声明：<code>const set = Symbol(str)</code></p>
</li>
<li><p>入参：字符串(可选)</p>
</li>
<li><p>方法</p>
<ol>
<li><p><code>Symbol()</code>：创建以参数作为描述的<code>Symbol值</code>(不登记在全局环境)</p>
</li>
<li><p><code>Symbol.for()</code>：创建以参数作为描述的<code>Symbol值</code>，如存在此参数则返回原有的<code>Symbol值</code>(先搜索后创建，登记在全局环境)</p>
</li>
<li><p><code>Symbol.keyFor()</code>：返回已登记的<code>Symbol值</code>的描述(只能返回<code>Symbol.for()</code>的<code>key</code>)</p>
</li>
<li><p><code>Object.getOwnPropertySymbols()</code>：返回对象中所有用作属性名的<code>Symbol值</code>的数组</p>
</li>
</ol>
</li>
<li><p>内置</p>
<ol>
<li><p><code>Symbol.hasInstance</code>：指向一个内部方法，当其他对象使用<code>instanceof</code>运算符判断是否为此对象的实例时会调用此方法</p>
</li>
<li><p><code>Symbol.isConcatSpreadable</code>：指向一个布尔值，定义对象用于<code>Array.prototype.concat()</code>时是否可展开</p>
</li>
<li><p><code>Symbol.species</code>：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</p>
</li>
<li><p><code>Symbol.match</code>：指向一个函数，当实例对象被<code>String.prototype.match()</code>调用时会重新定义<code>match()</code>的行为</p>
</li>
<li><p><code>Symbol.replace</code>：指向一个函数，当实例对象被<code>String.prototype.replace()</code>调用时会重新定义<code>replace()</code>的行为</p>
</li>
<li><p><code>Symbol.search</code>：指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义<code>search()</code>的行为</p>
</li>
<li><p><code>Symbol.split</code>：指向一个函数，当实例对象被<code>String.prototype.split()</code>调用时会重新定义<code>split()</code>的行为</p>
</li>
<li><p><code>Symbol.iterator</code>：指向一个默认遍历器方法，当实例对象执行<code>for-of</code>时会调用指定的默认遍历器</p>
</li>
<li><p><code>Symbol.toPrimitive</code>：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</p>
</li>
<li><p><code>Symbol.toStringTag</code>：指向一个函数，当实例对象被<code>Object.prototype.toString()</code>调用时其返回值会出现在<code>toString()</code>返回的字符串之中表示对象的类型</p>
</li>
<li><p><code>Symbol.unscopables</code>：指向一个对象，指定使用<code>with</code>时哪些属性会被<code>with环境</code>排除</p>
</li>
</ol>
</li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ol>
<li><p>定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</p>
</li>
<li><p>声明：<code>const set = new Set(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator</code>接口的数据结构</p>
</li>
<li><p>属性</p>
<ol>
<li><p><code>constructor</code>：构造函数，返回Set</p>
</li>
<li><p><code>size</code>：返回实例成员总数</p>
</li>
</ol>
</li>
<li><p>方法</p>
<ul>
<li><p><code>add()</code>：添加值，返回实例</p>
</li>
<li><p><code>delete()</code>：删除值，返回布尔值</p>
</li>
<li><p><code>has()</code>：检查值，返回布尔值</p>
</li>
<li><p><code>clear()</code>：清除所有成员</p>
</li>
<li><p><code>keys()</code>：返回以属性值为遍历器的对象</p>
</li>
<li><p><code>values()</code>：返回以属性值为遍历器的对象</p>
</li>
<li><p><code>entries()</code>：返回以属性值和属性值为遍历器的对象</p>
</li>
<li><p><code>forEach()</code>：使用回调函数遍历每个成员</p>
</li>
</ul>
</li>
<li><p>应用</p>
<ol>
<li><p>去重字符串：<code>[...new Set(str)].join(&quot;&quot;)</code></p>
</li>
<li><p>去重数组：<code>[...new Set(arr)]</code>或<code>Array.from(new Set(arr))</code></p>
</li>
<li><p>集合数组</p>
<ol>
<li><p>声明：<code>const a = new Set(arr1)</code>、<code>const b = new Set(arr2)</code></p>
</li>
<li><p>并集：<code>new Set([...a, ...b])</code></p>
</li>
<li><p>交集：<code>new Set([...a].filter(v =&gt; b.has(v)))</code></p>
</li>
<li><p>差集：<code>new Set([...a].filter(v =&gt; !b.has(v)))</code></p>
</li>
</ol>
</li>
<li><p>映射集合</p>
<ol>
<li><p>声明：<code>let set = new Set(arr)</code></p>
</li>
<li><p>映射：<code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>遍历顺序：插入顺序</p>
</li>
<li><p>没有键只有值，可认为键和值两值相等</p>
</li>
<li><p>添加多个<code>NaN</code>时，只会存在一个<code>NaN</code></p>
</li>
<li><p>添加相同的对象时，会认为是不同的对象</p>
</li>
<li><p>添加值时不会发生类型转换(<code>5 !== &quot;5&quot;</code>)</p>
</li>
<li><p><code>keys()</code>和<code>values()</code>的行为完全一致，<code>entries()</code>返回的遍历器同时包括键和值且两值相等</p>
</li>
</ol>
</li>
</ol>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><ol>
<li><p>定义：和<code>Set</code>结构类似，成员值只能是对象</p>
</li>
<li><p>声明：<code>const set = new WeakSet(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator</code>接口的数据结构</p>
</li>
<li><p>属性</p>
<ul>
<li><code>constructor</code>：构造函数，返回<code>WeakSet</code></li>
</ul>
</li>
<li><p>方法</p>
<ol>
<li><p><code>add()</code>：添加值，返回实例</p>
</li>
<li><p><code>delete()</code>：删除值，返回布尔值</p>
</li>
<li><p><code>has()</code>：检查值，返回布尔值</p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>成员都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakSet</code>结构对此成员的引用</p>
</li>
<li><p>成员不适合引用，它会随时消失，因此ES6规定<code>WeakSet</code>结构不可遍历</p>
</li>
<li><p>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakSet</code>结构中</p>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>储存<code>DOM</code>节点：<code>DOM</code>节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</p>
</li>
<li><p>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在<code>WeakSet</code>结构中的引用就会自动消</p>
</li>
</ol>
</li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol>
<li><p>定义：类似于对象的数据结构，成员键是任何类型的值</p>
</li>
<li><p>声明：<code>const set = new Map(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator</code>接口且每个成员都是一个双元素数组的数据结构</p>
</li>
<li><p>属性</p>
<ol>
<li><p><code>constructor</code>：构造函数，返回<code>Map</code></p>
</li>
<li><p><code>size</code>：返回实例成员总数</p>
</li>
</ol>
</li>
<li><p>方法</p>
<ol>
<li><p><code>get()</code>：返回键值对</p>
</li>
<li><p><code>set()</code>：添加键值对，返回实例</p>
</li>
<li><p><code>delete()</code>：删除键值对，返回布尔值</p>
</li>
<li><p><code>has()</code>：检查键值对，返回布尔值</p>
</li>
<li><p><code>clear()</code>：清除所有成员</p>
</li>
<li><p><code>keys()</code>：返回以键为遍历器的对象</p>
</li>
<li><p><code>values()</code>：返回以值为遍历器的对象</p>
</li>
<li><p><code>entries()</code>：返回以键和值为遍历器的对象</p>
</li>
<li><p><code>forEach()</code>：使用回调函数遍历每个成员</p>
</li>
</ol>
</li>
</ol>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><ol>
<li><p>定义：和<code>Map</code>结构类似，成员键只能是对象</p>
</li>
<li><p>声明：<code>const set = new WeakMap(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator</code>接口且每个成员都是一个双元素数组的数据结构</p>
</li>
<li><p>属性</p>
<ul>
<li><code>constructor</code>：构造函数，返回<code>WeakMap</code></li>
</ul>
</li>
<li><p>方法</p>
<ol>
<li><p><code>get()</code>：返回键值对</p>
</li>
<li><p><code>set()</code>：添加键值对，返回实例</p>
</li>
<li><p><code>delete()</code>：删除键值对，返回布尔值</p>
</li>
<li><p><code>has()</code>：检查键值对，返回布尔值</p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>成员键都是弱引用，垃圾回收机制不考虑<code>WeakMap</code>结构对此成员键的引用</p>
</li>
<li><p>成员键不适合引用，它会随时消失，因此ES6规定<code>WeakMap</code>结构不可遍历</p>
</li>
<li><p>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap</code>结构中</p>
</li>
<li><p>一旦不再需要，成员会自动消失，不用手动删除引用</p>
</li>
<li><p>弱引用的只是键而不是值，值依然是正常引用</p>
</li>
<li><p>即使在外部消除了成员键的引用，内部的成员值依然存在</p>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>储存<code>DOM</code>节点：<code>DOM</code>节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</p>
</li>
<li><p>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</p>
</li>
</ol>
</li>
</ol>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><ol>
<li><p>修改某些操作的默认行为</p>
</li>
<li><p>声明：<code>const proxy = new Proxy(target, handler)</code></p>
</li>
<li><p>入参</p>
<ol>
<li><p><code>target</code>：拦截的目标对象</p>
</li>
<li><p><code>handler</code>：定制拦截行为</p>
</li>
</ol>
</li>
<li><p>方法</p>
<ul>
<li><code>Proxy.revocable()</code>：返回可取消的<code>Proxy</code>实例(返回<code>&#123; proxy, revoke &#125;</code>，通过<code>revoke()</code>取消代理)</li>
</ul>
</li>
<li><p>拦截方式</p>
<ol>
<li><p><code>get()</code>：拦截对象属性读取</p>
</li>
<li><p><code>set()</code>：拦截对象属性设置，返回布尔值</p>
</li>
<li><p><code>has()</code>：拦截对象属性检查<code>k in obj</code>，返回布尔值</p>
</li>
<li><p><code>deleteProperty()</code>：拦截对象属性删除<code>delete obj[k]</code>，返回布尔值</p>
</li>
<li><p><code>defineProperty()</code>：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔值</p>
</li>
<li><p><code>ownKeys()</code>：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>，返回数组</p>
</li>
<li><p><code>getOwnPropertyDescriptor()</code>：拦截对象属性描述读取<code>Object.getOwnPropertyDescriptor()</code>，返回对象</p>
</li>
<li><p><code>getPrototypeOf()</code>：拦截对象原型读取<code>instanceof</code>、<code>Object.getPrototypeOf()</code>、<code>Object.prototype.__proto__</code>、<code>Object.prototype.isPrototypeOf()</code>、<code>Reflect.getPrototypeOf()</code>，返回对象</p>
</li>
<li><p><code>setPrototypeOf()</code>：拦截对象原型设置<code>Object.setPrototypeOf()</code>，返回布尔值</p>
</li>
<li><p><code>isExtensible()</code>：拦截对象是否可扩展读取<code>Object.isExtensible()</code>，返回布尔值</p>
</li>
<li><p><code>preventExtensions()</code>：拦截对象不可扩展设置<code>Object.preventExtensions()</code>，返回布尔值</p>
</li>
<li><p><code>apply()</code>：拦截Proxy实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></p>
</li>
<li><p><code>construct()</code>：拦截Proxy实例作为构造函数调用<code>new proxy()</code></p>
</li>
<li><p>注意</p>
<ol>
<li><p>要使<code>Proxy</code>起作用，必须针对实例进行操作，而不是针对目标对象进行操作</p>
</li>
<li><p>没有设置任何拦截时，等同于直接通向原对象</p>
</li>
<li><p>属性被定义为不可读写&#x2F;扩展&#x2F;配置&#x2F;枚举时，使用拦截方法会报错</p>
</li>
<li><p>代理下的目标对象，内部<code>this</code>指向<code>Proxy</code>代理</p>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p><code>Proxy.revocable()</code>：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</p>
</li>
<li><p><code>get()</code>：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成<code>DOM</code>嵌套节点</p>
</li>
<li><p><code>set()</code>：数据绑定(<code>Vue</code>数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</p>
</li>
<li><p><code>has()</code>：隐藏内部属性不被发现、排除不符合属性条件的对象</p>
</li>
<li><p><code>deleteProperty()</code>：保护内部属性不被删除</p>
</li>
<li><p><code>defineProperty()</code>：阻止属性被外部定义</p>
</li>
<li><p><code>ownKeys()</code>：保护内部属性不被遍历</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><ol>
<li><p>定义：保持<code>Object</code>方法的默认行为</p>
</li>
<li><p>方法</p>
<ol>
<li><p><code>get()</code>：返回对象属性</p>
</li>
<li><p><code>set()</code>：设置对象属性，返回布尔值</p>
</li>
<li><p><code>has()</code>：检查对象属性，返回布尔值</p>
</li>
<li><p><code>deleteProperty()</code>：删除对象属性，返回布尔值</p>
</li>
<li><p><code>defineProperty()</code>：定义对象属性，定义的属性默认是不可枚举，返回布尔值</p>
</li>
<li><p><code>ownKeys()</code>：遍历对象属性，返回数组(<code>Object.getOwnPropertyNames()</code>+<code>Object.getOwnPropertySymbols()</code>)</p>
</li>
<li><p><code>getOwnPropertyDescriptor()</code>：返回对象属性描述，返回对象</p>
</li>
<li><p><code>getPrototypeOf()</code>：返回对象原型，返回对象</p>
</li>
<li><p><code>setPrototypeOf()</code>：设置对象原型，返回布尔值</p>
</li>
<li><p><code>isExtensible()</code>：返回对象是否可扩展，返回布尔值</p>
</li>
<li><p><code>preventExtensions()</code>：设置对象不可扩展，返回布尔值</p>
</li>
<li><p><code>apply()</code>：绑定this后执行指定函数</p>
</li>
<li><p><code>construct()</code>：调用构造函数创建实例</p>
</li>
</ol>
</li>
</ol>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ol>
<li><p>定义：对一类具有共同特征的事物的抽象(构造函数语法糖)</p>
</li>
<li><p>原理：类本身指向构造函数，所有方法定义在<code>prototype</code>上，可看作构造函数的另一种写法(<code>Class === Class.prototype.constructor</code>)</p>
</li>
<li><p>方法和关键字</p>
<ol>
<li><p><code>constructor()</code>：构造函数，<code>new</code>命令生成实例时自动调用</p>
</li>
<li><p><code>extends</code>：继承父类</p>
</li>
<li><p><code>super</code>：新建父类的<code>this</code></p>
</li>
<li><p><code>static</code>：定义静态属性方法</p>
</li>
<li><p><code>get</code>：取值函数，拦截属性的取值行为</p>
</li>
<li><p><code>set</code>：存值函数，拦截属性的存值行为</p>
</li>
</ol>
</li>
<li><p>属性</p>
<ol>
<li><p><code>proto</code>：构造函数的继承(总是指向父类)</p>
</li>
<li><p><code>proto.proto</code>：子类的原型的原型，即父类的原型(总是指向父类的<code>__proto__</code>)</p>
</li>
<li><p><code>prototype.proto</code>：属性方法的继承(总是指向父类的<code>prototype</code>)</p>
</li>
</ol>
</li>
<li><p>静态属性：定义类完成后赋值属性，该属性不会被实例继承，只能通过类来调用</p>
</li>
<li><p>静态方法：使用<code>static</code>定义方法，该方法不会被实例继承，只能通过类来调用(方法中的<code>this</code>指向类，而不是实例)</p>
</li>
<li><p>继承</p>
<ol>
<li><p>实质</p>
<ol>
<li><p>ES5实质：先创造子类实例的<code>this</code>，再将父类的属性方法添加到<code>this</code>上(<code>Parent.apply(this)</code>)</p>
</li>
<li><p>ES6实质：先将父类实例的属性方法加到<code>this</code>上(调用<code>super()</code>)，再用子类构造函数修改<code>this</code></p>
</li>
</ol>
</li>
<li><p><code>super</code></p>
<ol>
<li><p>作为函数调用：只能在构造函数中调用<code>super()</code>，内部<code>this</code>指向继承的当前子类(<code>super()</code>调用后才可在构造函数中使用<code>this</code>)</p>
</li>
<li><p>作为对象调用：在普通方法中指向父类的原型对象，在静态方法中指向父类</p>
</li>
</ol>
</li>
<li><p>显示定义：使用<code>constructor() &#123; super(); &#125;</code>定义继承父类，没有书写则显示定义</p>
</li>
<li><p>子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用<code>super()</code>，否则得不到父类的<code>this</code></p>
<ol>
<li><p>父类静态属性方法可被子类继承</p>
</li>
<li><p>子类继承父类后，可从<code>super</code>上调用父类静态属性方法</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>实例：类相当于实例的原型，所有在类中定义的属性方法都会被实例继承</p>
<ol>
<li><p>显式指定属性方法：使用<code>this</code>指定到自身上(使用<code>Class.hasOwnProperty()</code>可检测到)</p>
</li>
<li><p>隐式指定属性方法：直接声明定义在对象原型上(使用<code>Class.__proto__.hasOwnProperty()</code>可检测到)</p>
</li>
</ol>
</li>
<li><p><code>this</code>指向：解构实例属性或方法时会报错</p>
</li>
<li><p>属性定义位置</p>
<ol>
<li><p>定义在构造函数中并使用<code>this</code>指向</p>
</li>
<li><p>定义在类最顶层</p>
</li>
</ol>
</li>
<li><p><code>new.target</code>：确定构造函数是如何调用</p>
</li>
<li><p>注意</p>
<ol>
<li><p>在实例上调用方法，实质是调用原型上的方法</p>
</li>
<li><p><code>Object.assign()</code>可方便地一次向类添加多个方法(<code>Object.assign(Class.prototype, &#123; ... &#125;)</code>)</p>
</li>
<li><p>类内部所有定义的方法是不可枚举的(<code>non-enumerable</code>)</p>
</li>
<li><p>构造函数默认返回实例对象(<code>this</code>)，可指定返回另一个对象</p>
</li>
<li><p>取值函数和存值函数设置在属性的<code>Descriptor</code>对象上</p>
</li>
<li><p>类不存在变量提升</p>
</li>
<li><p>利用<code>new.target === Class</code>写出不能独立使用必须继承后才能使用的类</p>
</li>
<li><p>子类继承父类后，<code>this</code>指向子类实例，通过<code>super</code>对某个属性赋值，赋值的属性会变成子类实例的属性</p>
</li>
<li><p>使用<code>super</code>时，必须显式指定是作为函数还是作为对象使用</p>
</li>
<li><p><code>extends</code>不仅可继承类还可继承原生的构造函数</p>
</li>
</ol>
</li>
</ol>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><ol>
<li><p>命令</p>
<ol>
<li><p><code>export</code>：规定模块对外接口</p>
<ol>
<li><p>默认导出：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</p>
</li>
<li><p>单独导出：<code>export const name = &quot;Bruce&quot;</code></p>
</li>
<li><p>按需导出：<code>export &#123; age, name, sex &#125;</code>(推荐)</p>
</li>
<li><p>改名导出：<code>export &#123; name as newName &#125;</code></p>
</li>
</ol>
</li>
<li><p><code>import</code>：导入模块内部功能</p>
<ol>
<li><p>默认导入：<code>import Person from &quot;person&quot;</code></p>
</li>
<li><p>整体导入：<code>import * as Person from &quot;person&quot;</code></p>
</li>
<li><p>按需导入：<code>import &#123; age, name, sex &#125; from &quot;person&quot;</code></p>
</li>
<li><p>改名导入：<code>import &#123; name as newName &#125; from &quot;person&quot;</code></p>
</li>
<li><p>自执导入：<code>import &quot;person&quot;</code></p>
</li>
<li><p>复合导入：<code>import Person, &#123; name &#125; from &quot;person&quot;</code></p>
</li>
</ol>
</li>
<li><p>复合模式：<code>export</code>命令和<code>import</code>命令结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量</p>
<ol>
<li><p>默认导入导出：<code>export &#123; default &#125; from &quot;person&quot;</code></p>
</li>
<li><p>整体导入导出：<code>export * from &quot;person&quot;</code></p>
</li>
<li><p>按需导入导出：<code>export &#123; age, name, sex &#125; from &quot;person&quot;</code></p>
</li>
<li><p>改名导入导出：<code>export &#123; name as newName &#125; from &quot;person&quot;</code></p>
</li>
<li><p>具名改默认导入导出：<code>export &#123; name as default &#125; from &quot;person&quot;</code></p>
</li>
<li><p>默认改具名导入导出：<code>export &#123; default as name &#125; from &quot;person&quot;</code></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>继承：默认导出和改名导出结合使用可使模块具备继承性</p>
</li>
<li><p>设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
</li>
<li><p>严格模式：ES6模块自动采用严格模式(不管模块头部是否添加<code>use strict</code>)</p>
</li>
<li><p>模块方案</p>
<ol>
<li><p><code>CommonJS</code>：用于服务器(动态化依赖)</p>
</li>
<li><p><code>AMD</code>：用于浏览器(动态化依赖)</p>
</li>
<li><p><code>CMD</code>：用于浏览器(动态化依赖)</p>
</li>
<li><p><code>UMD</code>：用于浏览器和服务器(动态化依赖)</p>
</li>
<li><p><code>ESM</code>：用于浏览器和服务器(静态化依赖)</p>
</li>
</ol>
</li>
<li><p>加载方式</p>
<ol>
<li><p>运行时加载</p>
<ol>
<li><p>定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)</p>
</li>
<li><p>影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化</p>
</li>
</ol>
</li>
<li><p>编译时加载</p>
<ol>
<li><p>定义：直接从模块中获取需要的属性和方法进行加载(按需加载)</p>
</li>
<li><p>影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(本身不是对象)，可拓展JS高级语法(宏和类型校验)</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>加载实现</p>
<ol>
<li><p>传统加载：通过<code>&lt;script&gt;</code>进行同步或异步加载脚本</p>
<ol>
<li><p>同步加载：<code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li><p><code>Defer</code>异步加载：<code>&lt;script src=&quot;&quot; defer&gt;&lt;/script&gt;</code>(顺序加载，渲染完再执行)</p>
</li>
<li><p><code>Async</code>异步加载：<code>&lt;script src=&quot;&quot; async&gt;&lt;/script&gt;</code>(乱序加载，下载完就执行)</p>
</li>
</ol>
</li>
<li><p>模块加载：<code>&lt;script type=&quot;module&quot; src=&quot;&quot;&gt;&lt;/script&gt;</code>(默认是<code>Defer</code>异步加载)</p>
</li>
</ol>
</li>
<li><p><code>CommonJS</code>和<code>ESM</code>的区别</p>
<ol>
<li><p><code>CommonJS</code>输出值的拷贝，<code>ESM</code>输出值的引用</p>
<ol>
<li><p><code>CommonJS</code>一旦输出一个值，模块内部的变化就影响不到这个值</p>
</li>
<li><p><code>ESM</code>是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值</p>
</li>
</ol>
</li>
<li><p><code>CommonJS</code>是运行时加载，<code>ESM</code>是编译时加载</p>
<ol>
<li><p><code>CommonJS</code>加载模块是对象(即<code>module.exports</code>)，该对象只有在脚本运行完才会生成</p>
</li>
<li><p><code>ESM</code>加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>循环加载</p>
<ol>
<li><p>定义：脚本A的执行依赖脚本B，而脚本A的执行又依赖脚本B</p>
</li>
<li><p>加载原理</p>
<ol>
<li><p><code>CommonJS</code>：<code>require()</code>首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取</p>
</li>
<li><p><code>ESM</code>：<code>import</code>命令加载变量不会被缓存，而是成为一个指向被加载模块的引用</p>
</li>
</ol>
</li>
<li><p>循环加载</p>
<ol>
<li><p><code>CommonJS</code>：只输出已经执行的部分，还未执行的部分不会输出</p>
</li>
<li><p><code>ESM</code>：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><code>import()</code>：动态导入(返回<code>Promise</code>)</p>
<ol>
<li><p>背景：<code>import</code>命令被JS引擎静态分析，先于模块内的其他语句执行，无法取代<code>require()</code>的动态加载功能，提案建议引入<code>import()</code>来代替<code>require()</code></p>
</li>
<li><p>位置：可在任何地方使用</p>
</li>
<li><p>区别：<code>require()</code>是同步加载，<code>import()</code>是异步加载</p>
</li>
<li><p>场景：按需加载、条件加载、模块路径动态化</p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p><code>ES6</code>模块中，顶层<code>this</code>指向<code>undefined</code>，不应该在顶层代码使用<code>this</code></p>
</li>
<li><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取</p>
</li>
<li><p><code>export</code>命令输出的接口与其对应的值是动态绑定关系，即通过该接口可获取模块内部实时的值</p>
</li>
<li><p><code>import</code>命令大括号里的变量名必须与被导入模块对外接口的名称相同</p>
</li>
<li><p><code>import</code>命令输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口</p>
</li>
<li><p><code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行</p>
</li>
<li><p>重复执行同一句<code>import</code>语句，只会执行一次</p>
</li>
<li><p><code>export default</code>命令只能使用一次</p>
</li>
<li><p><code>export default</code>命令导出的整体模块，在执行<code>import</code>命令时其后不能跟大括号</p>
</li>
<li><p><code>export default</code>命令本质是输出一个名为<code>default</code>的变量，后面不能跟变量声明语句</p>
</li>
<li><p><code>export default</code>命令本质是将后面的值赋给名为<code>default</code>的变量，可直接将值写在其后</p>
</li>
<li><p><code>export default</code>命令和<code>export &#123;&#125;</code>命令可同时存在，对应复合导入</p>
</li>
<li><p><code>export</code>命令和<code>import</code>命令可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域</p>
</li>
<li><p><code>import()</code>加载模块成功后，此模块会作为一个对象，当作<code>then()</code>的参数，可使用对象解构赋值来获取输出接口</p>
</li>
<li><p>同时动态加载多个模块时，可使用<code>Promise.all()</code>和<code>import()</code>相结合来实现</p>
</li>
<li><p><code>import()</code>和结合<code>async/await</code>来书写同步操作的代码</p>
</li>
</ol>
</li>
</ol>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><ol>
<li><p>定义：为各种不同的数据结构提供统一的访问机制</p>
</li>
<li><p>原理：创建一个指针指向首个成员，按照次序使用<code>next()</code>指向下一个成员，直接到结束位置(数据结构只要部署<code>Iterator</code>接口就可完成遍历操作)</p>
</li>
<li><p>作用</p>
<ol>
<li><p>为各种数据结构提供一个统一的简便的访问接口</p>
</li>
<li><p>使得数据结构成员能够按某种次序排列</p>
</li>
<li><p><code>ES6</code>创造了新的遍历命令<code>for-of</code>，<code>Iterator</code>接口主要供<code>for-of</code>消费</p>
</li>
</ol>
</li>
<li><p>形式：<code>for-of</code>(自动去寻找<code>Iterator</code>接口)</p>
</li>
<li><p>数据结构</p>
<ol>
<li><p>集合：<code>Array</code>、<code>Object</code>、<code>Set</code>、<code>Map</code></p>
</li>
<li><p>原生具备接口的数据结构：<code>String</code>、<code>Array</code>、<code>Set</code>、<code>Map</code>、<code>TypedArray</code>、<code>Arguments</code>、<code>NodeList</code></p>
</li>
</ol>
</li>
<li><p>部署：默认部署在<code>Symbol.iterator</code>(具备此属性被认为可遍历的<code>iterable</code>)</p>
</li>
<li><p>遍历器对象</p>
<ol>
<li><p><code>next()</code>：下一步操作，返回<code>&#123; done, value &#125;</code>(必须部署)</p>
</li>
<li><p><code>return()</code>：<code>for-of</code>提前退出调用，返回<code>&#123; done: true &#125;</code></p>
</li>
<li><p><code>throw()</code>：不使用，配合<code>Generator</code>函数使用</p>
</li>
</ol>
</li>
<li><p><code>for-of</code>循环</p>
<ol>
<li><p>定义：调用<code>Iterator</code>接口产生遍历器对象(<code>for-of</code>内部调用数据结构的<code>Symbol.iterator()</code>)</p>
</li>
<li><p>遍历字符串：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code>(可识别32位<code>UTF-16</code>字符)</p>
</li>
<li><p>遍历数组：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code></p>
</li>
<li><p>遍历对象：<code>for-in</code>获取<code>键</code>，<code>for-of</code>需自行部署</p>
</li>
<li><p>遍历<code>Set</code>：<code>for-of</code>获取<code>值</code> &#x3D;&gt; <code>for (const v of set)</code></p>
</li>
<li><p>遍历<code>Map</code>：<code>for-of</code>获取<code>键值对</code> &#x3D;&gt; <code>for (const [k, v] of map)</code></p>
</li>
<li><p>遍历类数组：包含<code>length</code>的对象、<code>Arguments</code>对象、<code>NodeList</code>对象(无<code>Iterator</code>接口的类数组可用<code>Array.from()</code>转换)</p>
</li>
<li><p>计算生成数据结构：<code>Array</code>、<code>Set</code>、<code>Map</code></p>
<ol>
<li><p><code>keys()</code>：返回遍历器对象，遍历所有的键</p>
</li>
<li><p><code>values()</code>：返回遍历器对象，遍历所有的值</p>
</li>
<li><p><code>entries()</code>：返回遍历器对象，遍历所有的键值对</p>
</li>
</ol>
</li>
<li><p>与<code>for-in</code>区别</p>
<ol>
<li><p>有着同<code>for-in</code>一样的简洁语法，但没有<code>for-in</code>那些缺点、</p>
</li>
<li><p>不同于<code>forEach()</code>，它可与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</p>
</li>
<li><p>提供遍历所有数据结构的统一操作接口</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>改写具有<code>Iterator</code>接口的数据结构的<code>Symbol.iterator</code></p>
</li>
<li><p>解构赋值：对<code>Set</code>进行解构</p>
</li>
<li><p>扩展运算符：将部署<code>Iterator</code>接口的数据结构转为数组</p>
</li>
<li><p><code>yield*</code>：<code>yield*</code>后跟一个可遍历的数据结构，会调用其遍历器接口</p>
</li>
<li><p>接受数组作为参数的函数：<code>for-of</code>、<code>Array.from()</code>、<code>new Set()</code>、<code>new WeakSet()</code>、<code>new Map()</code>、<code>new WeakMap()</code>、<code>Promise.all()</code>、<code>Promise.race()</code></p>
</li>
</ol>
</li>
</ol>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ol>
<li><p>定义：包含异步操作结果的对象</p>
</li>
<li><p>状态</p>
<ol>
<li><p>进行中：<code>pending</code></p>
</li>
<li><p>已成功：<code>resolved</code></p>
</li>
<li><p>已失败：<code>rejected</code></p>
</li>
</ol>
</li>
<li><p>特点</p>
<ol>
<li><p>对象的状态不受外界影响</p>
</li>
<li><p>一旦状态改变就不会再变，任何时候都可得到这个结果</p>
</li>
</ol>
</li>
<li><p>声明：<code>new Promise((resolve, reject) =&gt; &#123;&#125;)</code></p>
</li>
<li><p>出参</p>
<ol>
<li><p><code>resolve</code>：将状态从未完成变为成功，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</p>
</li>
<li><p><code>reject</code>：将状态从未完成变为失败，在异步操作失败时调用，并将异步操作的错误作为参数传递出去</p>
</li>
</ol>
</li>
<li><p>方法</p>
<ol>
<li><p><code>then()</code>：分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数</p>
<ol>
<li><p>第一参数：状态变为<code>resolved</code>时调用</p>
</li>
<li><p>第二参数：状态变为<code>rejected</code>时调用(可选)</p>
</li>
</ol>
</li>
<li><p><code>catch()</code>：指定发生错误时的回调函数</p>
</li>
<li><p><code>Promise.all()</code>：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)</p>
<ol>
<li><p>入参：具有<code>Iterator</code>接口的数据结构</p>
</li>
<li><p>成功：只有全部实例状态变成<code>fulfilled</code>，最终状态才会变成<code>fulfilled</code></p>
</li>
<li><p>失败：其中一个实例状态变成<code>rejected</code>，最终状态就会变成<code>rejected</code></p>
</li>
</ol>
</li>
<li><p><code>Promise.race()</code>：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)</p>
<ol>
<li><p>入参：具有<code>Iterator</code>接口的数据结构</p>
</li>
<li><p>成功失败：哪个实例率先改变状态就返回哪个实例的状态</p>
</li>
</ol>
</li>
<li><p><code>Promise.resolve()</code>：将对象转为Promise对象(等价于<code>new Promise(resolve =&gt; resolve())</code>)</p>
<ol>
<li><p><code>Promise</code>实例：原封不动地返回入参</p>
</li>
<li><p><code>Thenable</code>对象：将此对象转为<code>Promise</code>对象并返回(<code>Thenable</code>为包含<code>then()</code>的对象，执行<code>then()</code>相当于执行此对象的<code>then()</code>)</p>
</li>
<li><p>不具有<code>then()</code>的对象：将此对象转为<code>Promise</code>对象并返回，状态为<code>resolved</code></p>
</li>
<li><p>不带参数：返回<code>Promise</code>对象，状态为<code>resolved</code></p>
</li>
</ol>
</li>
<li><p><code>Promise.reject()</code>：将对象转为状态为<code>rejected</code>的<code>Promise</code>对象(等价于<code>new Promise((resolve, reject) =&gt; reject())</code>)</p>
</li>
<li><p><code>Promise.finally()</code>：指定不管最后状态如何都会执行的回调函数</p>
</li>
<li><p><code>Promise.allSettled()</code>：将多个实例包装成一个新实例，返回全部实例状态变更后的状态数组(齐变更再返回)</p>
<ol>
<li><p>入参：具有<code>Iterator</code>接口的数据结构</p>
</li>
<li><p>成功：成员包含<code>status</code>和<code>value</code>，<code>status</code>为<code>fulfilled</code>，<code>value</code>为返回值</p>
</li>
<li><p>失败：成员包含<code>status</code>和<code>reason</code>，<code>status</code>为<code>rejected</code>，<code>value</code>为错误原因</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><ol>
<li><p>定义：封装多个内部状态的异步编程解决方案</p>
</li>
<li><p>形式：调用<code>Generator</code>函数(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</p>
</li>
<li><p>声明：<code>function* Func() &#123;&#125;</code></p>
</li>
<li><p>方法</p>
<ol>
<li><p><code>next()</code>：使指针移向下一个状态，返回<code>&#123; done, value &#125;</code>(入参会被当作上一个<code>yield</code>命令表达式的返回值)</p>
</li>
<li><p><code>return()</code>：返回指定值且终结遍历<code>Generator</code>函数，返回<code>&#123; done: true, value: 入参 &#125;</code></p>
</li>
<li><p><code>throw()</code>：在<code>Generator</code>函数体外抛出错误，在<code>Generator</code>函数体内捕获错误，返回自定义的<code>new Errow()</code></p>
</li>
</ol>
</li>
<li><p><code>yield</code>命令：声明内部状态的值(<code>return</code>声明结束返回的值)</p>
<ol>
<li><p>遇到<code>yield</code>命令就暂停执行后面的操作，并将其后表达式的值作为返回对象的<code>value</code></p>
</li>
<li><p>下次调用<code>next()</code>时，再继续往下执行直到遇到下一个<code>yield</code>命令</p>
</li>
<li><p>没有再遇到<code>yield</code>命令就一直运行到<code>Generator</code>函数结束，直到遇到<code>return</code>语句为止并将其后表达式的值作为返回对象的<code>value</code></p>
</li>
<li><p><code>Generator</code>函数没有<code>return</code>语句<code>则返</code>回对象的<code>value</code>为<code>undefined</code></p>
</li>
</ol>
</li>
<li><p><code>yield*</code>命令：在一个<code>Generator</code>函数里执行另一个<code>Generator</code>函数(后随具有<code>Iterator</code>接口的数据结构)</p>
</li>
<li><p>遍历：通过<code>for-of</code>自动调用<code>next()</code></p>
</li>
<li><p>作为对象属性</p>
<ol>
<li><p>全写：<code>const obj = &#123; method: function*() &#123;&#125; &#125;</code></p>
</li>
<li><p>简写：<code>const obj = &#123; * method() &#123;&#125; &#125;</code></p>
</li>
</ol>
</li>
<li><p>上下文：执行产生的上下文环境一旦遇到<code>yield</code>命令就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在当前状态，等到对它执行<code>next()</code>时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行</p>
</li>
<li><p>方法异同</p>
<ol>
<li><p>相同点：<code>next()</code>、<code>throw()</code>、<code>return()</code>本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换<code>yield命令</code></p>
</li>
<li><p>不同点</p>
<ol>
<li><p><code>next()</code>：将<code>yield</code>命令替换成一个值</p>
</li>
<li><p><code>return()</code>：将<code>yield</code>命令替换成一个<code>return</code>语句</p>
</li>
<li><p><code>throw()</code>：将<code>yield</code>命令替换成一个<code>throw</code>语句</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>每次调用<code>next()</code>，指针就从函数头部或<code>上</code>次停下的位置开始执行，直到遇到下一个<code>yield</code>命令或<code>return</code>语句为止</p>
</li>
<li><p>函数内部可不用<code>yield</code>命令，但会变成单纯的暂缓执行函数(还是需要<code>next()</code>触发)</p>
</li>
<li><p><code>yield</code>命令是暂停执行的标记，<code>next()</code>是恢复执行的操作</p>
</li>
<li><p><code>yield</code>命令用在另一个表达式中必须放在圆括号里</p>
</li>
<li><p><code>yield</code>命令用作函数参数或放在赋值表达式的右边，可不加圆括号</p>
</li>
<li><p><code>yield</code>命令本身没有返回值，可认为是返回<code>undefined</code></p>
</li>
<li><p><code>yield</code>命令表达式为惰性求值，等<code>next()</code>执行到此才求值</p>
</li>
<li><p>函数调用后生成遍历器对象，此对象的<code>Symbol.iterator</code>是此对象本身</p>
</li>
<li><p>在函数运行的不同阶段，通过<code>next()</code>从外部向内部注入不同的值，从而调整函数行为</p>
</li>
<li><p>首个<code>next()</code>用来启动遍历器对象，后续才可传递参数</p>
</li>
<li><p>想首次调用<code>next()</code>时就能输入值，可在函数外面再包一层</p>
</li>
<li><p>一旦<code>next()</code>返回对象的<code>done</code>为<code>true</code>，<code>for-of</code>遍历会中止且不包含该返回对象</p>
</li>
<li><p>函数内部部署<code>try-finally</code>且正在执行<code>try</code>，那么<code>return()</code>会导致立刻进入<code>finally</code>，执行完<code>finally</code>以后整个函数才会结束</p>
</li>
<li><p>函数内部没有部署<code>try-catch</code>，<code>throw()</code>抛错将被外部<code>try-catch</code>捕获</p>
</li>
<li><p><code>throw()</code>抛错要被内部捕获，前提是必须至少执行过一次<code>next()</code></p>
</li>
<li><p><code>throw()</code>被捕获以后，会附带执行下一条<code>yield</code>命令</p>
</li>
<li><p>函数还未开始执行，这时<code>throw()</code>抛错只可能抛出在函数外部</p>
</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>异步操作同步化表达</p>
</li>
<li><p>控制流管理</p>
</li>
<li><p>为对象部署<code>Iterator</code>接口：把<code>Generator</code>函数赋值给对象的<code>Symbol.iterator</code>，从而使该对象具有<code>Iterator</code>接口</p>
</li>
<li><p>作为具有<code>Iterator</code>接口的数据结构</p>
</li>
</ol>
</li>
</ol>
<h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2><ol>
<li><p>定义：使异步函数以同步函数的形式书写(<code>Generator</code>函数语法糖)</p>
</li>
<li><p>原理：将<code>Generator</code>函数和自动执行器<code>spawn</code>包装在一个函数里</p>
</li>
<li><p>形式：将<code>Generator</code>函数的<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></p>
</li>
<li><p>声明</p>
<ol>
<li><p>具名函数：<code>async function Func() &#123;&#125;</code></p>
</li>
<li><p>函数表达式：<code>const func = async function() &#123;&#125;</code></p>
</li>
<li><p>箭头函数：<code>const func = async() =&gt; &#123;&#125;</code></p>
</li>
<li><p>对象方法：<code>const obj = &#123; async func() &#123;&#125; &#125;</code></p>
</li>
<li><p>类方法：<code>class Cla &#123; async Func() &#123;&#125; &#125;</code></p>
</li>
</ol>
</li>
<li><p><code>await</code>命令：等待当前<code>Promise</code>对象状态变更完毕</p>
<ol>
<li><p>正常情况：后面是<code>Promise</code>对象则返回其结果，否则返回对应的值</p>
</li>
<li><p>后随<code>Thenable</code>对象：将其等同于<code>Promise</code>对象返回其结果</p>
</li>
</ol>
</li>
<li><p>错误处理：将<code>await</code>命令<code>Promise</code>对象放到<code>try-catch</code>中(可放多个)</p>
</li>
<li><p>异步迭代器(<code>for-await-of</code>)：循环等待每个<code>Promise</code>对象变为<code>resolved</code>状态才进入下一步</p>
</li>
<li><p><code>Async</code>对<code>Generator</code>改进</p>
<ol>
<li><p>内置执行器</p>
</li>
<li><p>更好的语义</p>
</li>
<li><p>更广的适用性</p>
</li>
<li><p>返回值是<code>Promise</code>对象</p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p><code>Async</code>函数返回<code>Promise</code>对象，可使用<code>then()</code>添加回调函数</p>
</li>
<li><p>内部<code>return</code>返回值会成为后续<code>then()</code>的出参</p>
</li>
<li><p>内部抛出错误会导致返回的<code>Promise</code>对象变为<code>rejected</code>状态，被<code>catch()</code>接收到</p>
</li>
<li><p>返回的<code>Promise</code>对象必须等到内部所有<code>await</code>命令<code>Promise</code>对象执行完才会发生状态改变，除非遇到<code>return</code>语句或抛出错误</p>
</li>
<li><p>任何一个<code>await</code>命令<code>Promise</code>对象变为<code>rejected</code>状态，整个<code>Async</code>函数都会中断执行</p>
</li>
<li><p>希望即使前一个异步操作失败也不要中断后面的异步操作</p>
<ol>
<li><p>将<code>await</code>命令<code>Promise</code>对象放到<code>try-catch</code>中</p>
</li>
<li><p><code>await</code>命令<code>Promise</code>对象跟一个<code>catch()</code></p>
</li>
</ol>
</li>
<li><p><code>await</code>命令<code>Promise</code>对象可能变为<code>rejected</code>状态，最好把其放到<code>try-catch</code>中</p>
</li>
<li><p>多个<code>await</code>命令<code>Promise</code>对象若不存在继发关系，最好让它们同时触发</p>
</li>
<li><p><code>await</code>命令只能用在<code>Async</code>函数之中，否则会报错</p>
</li>
<li><p>数组使用<code>forEach()</code>执行<code>async/await</code>会失效，可使用<code>for-of</code>和<code>Promise.all()</code>代替</p>
</li>
<li><p>可保留运行堆栈，函数上下文随着<code>Async</code>函数的执行而存在，执行完成就消失</p>
</li>
</ol>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/" title="ES6 入门教程 - ECMAScript 6入门 (ruanyifeng.com)">ES6 入门教程 - ECMAScript 6入门 (ruanyifeng.com)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903959283367950" title="https://juejin.cn/post/6844903959283367950">https://juejin.cn/post/6844903959283367950</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7133397098719870990" title="你到底懂不懂JavaScript？来做做这12道面试题试试！ - 掘金 (juejin.cn)">你到底懂不懂JavaScript？来做做这12道面试题试试！ - 掘金 (juejin.cn)</a></p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ES6/" rel="tag"># ES6</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/16/%E5%89%8D%E7%AB%AF%E9%A6%96%E9%A1%B5%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/" rel="prev" title="前端首页加载优化">
      <i class="fa fa-chevron-left"></i> 前端首页加载优化
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6%E7%89%B9%E6%80%A7"><span class="nav-number"></span> <span class="nav-text">ES6特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E"><span class="nav-number">1.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">2.</span> <span class="nav-text">解构赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95"><span class="nav-number">3.</span> <span class="nav-text">字符串扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E6%89%A9%E5%B1%95"><span class="nav-number">4.</span> <span class="nav-text">数值扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95"><span class="nav-number">5.</span> <span class="nav-text">对象扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95"><span class="nav-number">6.</span> <span class="nav-text">数组扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95"><span class="nav-number">7.</span> <span class="nav-text">函数扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E6%89%A9%E5%B1%95"><span class="nav-number">8.</span> <span class="nav-text">正则扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Symbol"><span class="nav-number">9.</span> <span class="nav-text">Symbol</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set"><span class="nav-number">10.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeakSet"><span class="nav-number">11.</span> <span class="nav-text">WeakSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">12.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeakMap"><span class="nav-number">13.</span> <span class="nav-text">WeakMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proxy"><span class="nav-number">14.</span> <span class="nav-text">Proxy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reflect"><span class="nav-number">15.</span> <span class="nav-text">Reflect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class"><span class="nav-number">16.</span> <span class="nav-text">Class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Module"><span class="nav-number">17.</span> <span class="nav-text">Module</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterator"><span class="nav-number">18.</span> <span class="nav-text">Iterator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise"><span class="nav-number">19.</span> <span class="nav-text">Promise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generator"><span class="nav-number">20.</span> <span class="nav-text">Generator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Async"><span class="nav-number">21.</span> <span class="nav-text">Async</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">22.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">YuanQiii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YuanQiii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">91k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:23</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<br />
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("10/01/2021 15:54:40");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
